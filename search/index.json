[{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/categories/docker/","title":"docker"},{"content":"","href":"/tags/docker-network/","title":"docker network"},{"content":"Containers need to communicate with each other and outside world.\nDocker has wide network capabilities.\nWhat we can do with docker network? How to use it?\nDocker Network Theory What elements we have in docker network?\n CNM libnetwork drivers  Docker network concept is based on open-source design specification called Container Network Model(CNM). CNM assume that network drivers should be pluggable.\nDocker CNM implementation is in libnetwork library.\nWhat we can do with docker CNM?\n single-host bridges multi-host overlay networks networks plugged into VLAN\u0026rsquo;s ingress networks with load balancing Also we get auto service discovery for our containers.  What elements we have in docker CNM implementation?\n sandboxes - container network stack - isolated - ethernet interfaces, ports, routing tables and DNS config endpoint - virtual interfaces in containers - veth networks - virtual switches(bridges) - connect endpoints  What drivers are built-in by default into docker(Linux)?\n bridge overlay macvlan  Single-host network bridge By default docker creates one brigde after instalation.\nAll containers are by default connected to it unless we override it.\nTo set another non-default network we use --network flag for docker run.\nWhat is the diference between default bridge and user created one:\n Default brigde is less secure - provide less isolation - by default all containers will be connected to it We can connect/disconnect containers from user defined bridges without restarting containers Defualt bridge does not have DNS included - we must use IP in such network - on user defined bridge we get DNS(all containers added to bridge network automatically will be added also to DNS) - just connect container to bridge and you can talk with other containers in network by their names(works for named containers with --name at creation time)  We can see that all default networks are local - what means that we can\u0026rsquo;t connect with them containers on multiple docker hosts.\n[root@docker-host1 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 740857ece0a5 bridge bridge local 13396ccbb663 host host local 44424eae56f4 none null local We can check details about default bridge network\n[root@docker-host1 ~]# docker network inspect bridge [ { \u0026#34;Name\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;740857ece0a5fc38891b919d2f7506e32e699b4e79a449f8fef9824d0cde39b2\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-05-07T21:07:19.137450998+02:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.17.0.0/16\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;172.17.0.1\u0026#34; } ] }, \u0026#34;Internal\u0026#34;: false, \u0026#34;Attachable\u0026#34;: false, \u0026#34;Ingress\u0026#34;: false, \u0026#34;ConfigFrom\u0026#34;: { \u0026#34;Network\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;ConfigOnly\u0026#34;: false, \u0026#34;Containers\u0026#34;: {}, \u0026#34;Options\u0026#34;: { \u0026#34;com.docker.network.bridge.default_bridge\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_icc\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.enable_ip_masquerade\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;com.docker.network.bridge.host_binding_ipv4\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34;, \u0026#34;com.docker.network.driver.mtu\u0026#34;: \u0026#34;1500\u0026#34; }, \u0026#34;Labels\u0026#34;: {} } ] As we see docker bridge is build on Linux bridge:\n\u0026#34;com.docker.network.bridge.name\u0026#34;: \u0026#34;docker0\u0026#34; [root@docker-host1 ~]# ip link show docker0 3: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default link/ether 02:42:9d:73:fa:48 brd ff:ff:ff:ff:ff:ff Creating network bridge [root@docker-host1 ~]# docker network create -d bridge lukas-bridge 3836e34c6950d80e032e322f915935b51472059ea19cfd65c409263c74ba2b45 [root@docker-host1 ~]# ip a \u0026lt;snip\u0026gt; 5: br-3836e34c6950: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:0b:b8:19:54 brd ff:ff:ff:ff:ff:ff inet 172.19.0.1/16 brd 172.19.255.255 scope global br-6c8ad698150b valid_lft forever preferred_lft forever As we see there is new bridge at OS level with name coresponding to ID of our newly created docker bridge.\nStarting container connected to new bridge [root@docker-host1 ~]# docker container run -d --name web_server --network lukas-bridge httpd 08e885099d0ebca6ab5b533bffd0245dccfaab79149657ad9161fe26c370b879 List containers connected to network [root@docker-host1 ~]# docker network inspect lukas-bridge --format \u0026#34;{{json .Containers}}\u0026#34; {\u0026#34;08e885099d0ebca6ab5b533bffd0245dccfaab79149657ad9161fe26c370b879\u0026#34;:{\u0026#34;Name\u0026#34;:\u0026#34;web_server\u0026#34;,\u0026#34;EndpointID\u0026#34;:\u0026#34;ade95c4b553f8cebfbf8f24338b6d0f9e7b2d41744c501816ac734d1bb8ccc1f\u0026#34;,\u0026#34;MacAddress\u0026#34;:\u0026#34;02:42:ac:14:00:02\u0026#34;,\u0026#34;IPv4Address\u0026#34;:\u0026#34;172.20.0.2/16\u0026#34;,\u0026#34;IPv6Address\u0026#34;:\u0026#34;\u0026#34;}} Test connection between containers connected to bridge If we use --name flag when creating container we can use docker built-in DNS feature. Containers automatically know hostname to ip mapping of other containers.\nCreate second container:\n[root@docker-host1 ~]# docker container run -d --name web_server2 --network lukas-bridge httpd 34bb16b0c43c64c935c8a44c0ed13fa2a7972f79700db290144eba54aa93336a Get into one of containers and ping other one\n[root@docker-host1 ~]# docker exec -it web_server2 /bin/bash root@34bb16b0c43c:/usr/local/apache2# ping web_server PING web_server (172.20.0.2) 56(84) bytes of data. 64 bytes from web_server (172.20.0.2): icmp_seq=1 ttl=64 time=0.712 ms 64 bytes from web_server (172.20.0.2): icmp_seq=2 ttl=64 time=0.649 ms ^C Changing DNS in container We can add DNS to container - this DNS will be queired when Docker built-in DNS won\u0026rsquo;t be able to resolve request.\n[root@docker-host1 ~]# docker run -d --dns 8.8.8.8 httpd 4bde944868b492a5cef84676de1cfb1a211069c67c494d4ab742115d4fc17ee9 [root@docker-host1 ~]# docker exec -it 4bde944868b492a5cef84676de1cfb1a211069c67c494d4ab742115d4fc17ee9 bash root@4bde944868b4:/usr/local/apache2# cat /etc/resolv.conf search lukas.int nameserver 8.8.8.8 Port mapping We can tell docker to expose port from container on docker host port that other server or clients can access service running in container.\nWe can achive this with --publish flag.\nStart container with port published We start container with httpd service which expose port 80 - to connect to this port in container we can connect to docker host on port 1234.\n[root@docker-host1 ~]# docker run -d --name web_server --network lukas-bridge --publish published=1234,target=80 httpd 304ddf53a801763c769545eb91c6c5522fc2eedf7cf5f4d252bace1d5e0b8a37 Check what ports are published from container [root@docker-host1 ~]# docker port web_server 80/tcp -\u0026gt; 0.0.0.0:1234 Connecting container directly to host network stack Docker gives us possibility to integrate container network stack into host stack.\nIn such situation container will not get his own IP address and MAC(neither externally from docker host network, neither internally from network created by docker engine) - he will be reachable as he will be normal software running on our host.\nThis is good solution if we want to run some software that use network but we want to have full isolation of process(pid), mount(mnt), user and IPC namespaces.\nTo active such mode we use --network=host parameter to docker run.\nIn this mode --publish doesn\u0026rsquo;t work - if service in container listen on port 80 - port 80 on docker host will be taken.\n[root@docker-host1 ~]# docker run -d --name web_server --network host httpd dedc6c9e1c05ccb3621fa4272975036f7b9266371a20221f3ba9dbc237eff3b0 If we inspect container we will see that there is no IP adress and network mode is set to host:\n[root@docker-host1 ~]# docker container inspect web_server [...] \u0026#34;NetworkMode\u0026#34;: \u0026#34;host\u0026#34;, \u0026#34;PortBindings\u0026#34;: { \u0026#34;80/tcp\u0026#34;: [ { \u0026#34;HostIp\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;HostPort\u0026#34;: \u0026#34;1234\u0026#34; } [..] \u0026#34;Networks\u0026#34;: { \u0026#34;host\u0026#34;: { \u0026#34;IPAMConfig\u0026#34;: null, \u0026#34;Links\u0026#34;: null, \u0026#34;Aliases\u0026#34;: null, \u0026#34;NetworkID\u0026#34;: \u0026#34;13396ccbb6635016d4381588204f9724401cf7200b67cb8f44f065ebfbb8f069\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;256edba4bd98f86e4a3af9331ff24aca958805ff5f0a3bb202fa67c0b8d4ab07\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;IPAddress\u0026#34;: \u0026#34;\u0026#34;, Apache server is listening correctly:\n[root@docker-host1 ~]# curl -X GET 127.0.0.1:80 \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;It works!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; Connecting container directly to host network - MACVLAN If we want to expose our container to world but it is important for us that container has got own IP and MAC adress from network where docker host is connected, we can use MACVLAN network driver. It allows also to connect to certain VLAN.\nIt will create for us docker network - all containers connected to this network will be visible in docker host network as they were normal separate from docker host that host them machines.\nRemember that:\n with MACVLAN you can easily exhaust IP adresses in your network you have to set network card in promiscious mode this solution is created mainly for legacy apps or network monitoring apps   Important! To use MACVLAN mode our network card has to be in promiscious mode!\nActiviting promoscius mode in CentOS(ens18 is my main network card):\n[root@docker-host1 ~]# ip link set ens18 promisc on Check if mode was activeted - PROMISC flag:\n[root@docker-host1 ~]# ip a [..] 2: ens18: \u0026lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 62:ae:db:67:8c:08 brd ff:ff:ff:ff:ff:ff inet 10.10.10.20/24 brd 10.10.10.255 scope global noprefixroute ens18 valid_lft forever preferred_lft forever inet6 fe80::8f98:eb7:2724:a548/64 scope link noprefixroute valid_lft forever preferred_lft forever [...]  As my docker host is in 10.10.10.0/24 network connected by ens18 network card, I will create proper network with macvlan driver.\nI also add --ip-range flag because I want that containers get IP\u0026rsquo;s from second half of my network(in first half are my docker hosts so with this flag I will avoid IP collision)\n[root@docker-host1 ~]# docker network create -d macvlan --subnet 10.10.10.0/24 --ip-range 10.10.10.128/25 --gateway 10.10.10.1 -o parent=ens18 lukas_macvlan 75a25e8867e6d2a6e91f3bfecfe70d5420b2049a474b4aeb97e792f23fce1ddf Let\u0026rsquo;s create some container connected to macvlan network.\n[root@docker-host1 ~]# docker run -d --network lukas_macvlan --name web_server httpd f856de1521116a70632126d014ff1b14e61b8309d3e41cb593b8be78bb29693f Check connectivity from inside container IP configuration:\n[root@docker-host1 ~]# docker exec -it web_server bash root@f856de152111:/usr/local/apache2# ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=52 time=38.2 ms 64 bytes from 8.8.8.8: icmp_seq=2 ttl=52 time=41.1 ms 64 bytes from 8.8.8.8: icmp_seq=3 ttl=52 time=83.1 ms 64 bytes from 8.8.8.8: icmp_seq=4 ttl=52 time=107 ms ^C --- 8.8.8.8 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 8ms rtt min/avg/max/mdev = 38.157/67.276/106.762/28.910 ms root@f856de152111:/usr/local/apache2# ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.10.10.128 netmask 255.255.255.0 broadcast 10.10.10.255 ether 02:42:0a:0a:0a:80 txqueuelen 0 (Ethernet) RX packets 3714 bytes 8949950 (8.5 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2252 bytes 159458 (155.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 We can see that our container is now in docker host network directly.\nLet\u0026rsquo;s check if we can ping in from another docker host in network\n[root@docker-host2 ~]# ping 10.10.10.128 PING 10.10.10.128 (10.10.10.128) 56(84) bytes of data. 64 bytes from 10.10.10.128: icmp_seq=1 ttl=64 time=0.703 ms 64 bytes from 10.10.10.128: icmp_seq=2 ttl=64 time=0.514 ms ^C --- 10.10.10.128 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 60ms rtt min/avg/max/mdev = 0.514/0.608/0.703/0.097 ms This feature gives us possibility to connect to multiple VLAN\u0026rsquo;s - we can have our containers in diffrent external networks all trunking with single network card of our docker host.\nOverlay network - multi-host - Docker Swarm Overlay network allows us to set communication between containers deployed on multiple nodes. We use this type of network in Swarm Clusters.\n For more information about Docker Swarm look at:\nDocker Swarm - complete guide\n Environment used - two host in diffrent networks connected by router:\n   Role in Swarm Server IP     Manager docker-host1.lukas.int 10.10.10.20   Worker1 docker-host2.lukas.int 192.168.1.100    Create overlay network Creating new network - we optionally use -o encrypted to make data in network secure\n[root@docker-host1 ~]# docker network create -d overlay -o encrypted lukas-overnet fyb4s4ydv3vnl6cjhq62ojdo6 Check overlay network On manager node:\n[root@docker-host1 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 6b9cea7d8900 bridge bridge local 5cbd99a08e42 docker_gwbridge bridge local 13396ccbb663 host host local di48hsm4e4fw ingress overlay swarm l4hcqght8ulh lukas-overnet overlay swarm 44424eae56f4 none null local On worker node:\n[root@docker-host2 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 7e16c6986b6c bridge bridge local b905ff175794 docker_gwbridge bridge local 1b02943d42e5 host host local di48hsm4e4fw ingress overlay swarm cde72e9ea1c3 none null local As we see new custom overlay networks are always visible on manager.\nNetwork will be visible on worker node as soon as there will be container attached to this network.\nAfter creating service connected to lukas-overnet - network starts to be visilble on docker-host2 worker\n[root@docker-host1 ~]# docker service create --name web_server --replicas 2 --network lukas-overnet httpd jktxvf185ab8d52uw1g3f74gw overall progress: 2 out of 2 tasks 1/2: running [==================================================\u0026gt;] 2/2: running [==================================================\u0026gt;] verify: Service converged [root@docker-host2 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 7e16c6986b6c bridge bridge local b905ff175794 docker_gwbridge bridge local 1b02943d42e5 host host local di48hsm4e4fw ingress overlay swarm l4hcqght8ulh lukas-overnet overlay swarm cde72e9ea1c3 none null local Inspect overlay network We can see that created network adressation not match any of docker host networks.\n[root@docker-host1 ~]# docker network inspect lukas-overnet [ { \u0026#34;Name\u0026#34;: \u0026#34;lukas-overnet\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;l4hcqght8ulhxydypdnh9l45f\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-05-11T20:39:30.261903606+02:00\u0026#34;, \u0026#34;Scope\u0026#34;: \u0026#34;swarm\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;overlay\u0026#34;, \u0026#34;EnableIPv6\u0026#34;: false, \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;10.0.2.0/24\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;10.0.2.1\u0026#34; } [...] Check container IP address [root@docker-host2 ~]# docker container inspect 71b279ce322b --format \u0026#34;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\u0026#34; 10.0.2.3 Test connection in overlay network Connection works with IP and container name also:\nroot@25d3dea663a0:/usr/local/apache2# ping 10.0.2.3 PING 10.0.2.3 (10.0.2.3) 56(84) bytes of data. 64 bytes from 10.0.2.3: icmp_seq=1 ttl=64 time=0.774 ms 64 bytes from 10.0.2.3: icmp_seq=2 ttl=64 time=0.777 ms 64 bytes from 10.0.2.3: icmp_seq=3 ttl=64 time=0.838 ms 64 bytes from 10.0.2.3: icmp_seq=4 ttl=64 time=0.602 ms ^C --- 10.0.2.3 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 84ms rtt min/avg/max/mdev = 0.602/0.747/0.838/0.094 ms root@25d3dea663a0:/usr/local/apache2# ping web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5 PING web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5 (10.0.2.3) 56(84) bytes of data. 64 bytes from web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5.lukas-overnet (10.0.2.3): icmp_seq=1 ttl=64 time=0.497 ms 64 bytes from web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5.lukas-overnet (10.0.2.3): icmp_seq=2 ttl=64 time=0.568 ms 64 bytes from web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5.lukas-overnet (10.0.2.3): icmp_seq=3 ttl=64 time=0.627 ms 64 bytes from web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5.lukas-overnet (10.0.2.3): icmp_seq=4 ttl=64 time=0.687 ms 64 bytes from web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5.lukas-overnet (10.0.2.3): icmp_seq=5 ttl=64 time=0.759 ms ^C --- web_server.1.ptbr9gbf7ygzn4i4dgoww6ne5 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 65ms rtt min/avg/max/mdev = 0.497/0.627/0.759/0.095 ms ","href":"/posts/docker_network/","title":"Docker network - complete guide"},{"content":"","href":"/","title":"IT Knowledge Pill"},{"content":"","href":"/authors/lbartnicki/","title":"lbartnicki"},{"content":"","href":"/posts/","title":"Posts"},{"content":"","href":"/tags/","title":"Tags"},{"content":"By default after installing docker on our host we have client and server(daemon) locally speaking to each other by IPC socket. On Linux - /var/run/docker.sock.\nSo what we should do when our daemon is in remote location? How to make connection secure?\nExample environment    Role Server IP     Client docker-host1.lukas.int 10.10.10.20   CA docker-host2.lukas.int 10.10.10.21   Daemon docker-host3.lukas.int 10.10.10.22    All hosts can reach each other by hostname.\nTLS Docker uses TLS for securing connection over network between client and daemon.\nWe will set this from both sides:\n Daemon will want to talk only to clients with proper certificate Client will want to talk only to daemon with proper certificate also  Self-signed cert - if we don\u0026rsquo;t have cert from CA  Private key for CA  [root@docker-host2 ~]# openssl genrsa -aes256 -out ca-key.pem 4096 Generating RSA private key, 4096 bit long modulus (2 primes) ...............................................................................................++++ ..............................................................................++++ e is 65537 (0x010001) Enter pass phrase for ca-key.pem: Verifying - Enter pass phrase for ca-key.pem:  Public key  [root@docker-host2 ~]# openssl req -new -x509 -days 730 -key ca-key.pem -sha256 -out ca.pem Enter pass phrase for ca-key.pem: You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Country Name (2 letter code) [XX]:PL State or Province Name (full name) []:Maz Locality Name (eg, city) [Default City]:Warsaw Organization Name (eg, company) [Default Company Ltd]:knowledgepill.it Organizational Unit Name (eg, section) []:BlogSite Common Name (eg, your name or your server\u0026#39;s hostname) []:docker-host2.lukas.int Generate key and certificate for daemon  Generate private key for daemon  [root@docker-host2 ~]# openssl genrsa -out daemon-key.pem 4096 Generating RSA private key, 4096 bit long modulus (2 primes) ...................................................................................................++++ ........................................................++++ e is 65537 (0x010001)  Request CA to sign certificate for daemon  [root@docker-host2 ~]# openssl req -subj \u0026#34;/CN=docker-host3\u0026#34; -sha256 -new -key daemon-key.pem -out daemon.csr  Add info to cert  [root@docker-host2 ~]# vi extfile.cnf subjectAltName = DNS:docker-host3,IP:10.10.10.22 extendedKeyUsage = serverAuth  Generate daemon certificate  [root@docker-host2 ~]# openssl x509 -req -days 730 -sha256 -in daemon.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out daemon-cert.pem -extfile extfile.cnf Signature ok subject=CN = docker-host3 Getting CA Private Key Enter pass phrase for ca-key.pem: Generate key and cert for client  Generate private key for client  [root@docker-host2 ~]# openssl genrsa -out client-key.pem 4096 Generating RSA private key, 4096 bit long modulus (2 primes) ......................++++ ....++++ e is 65537 (0x010001)  Request CA to sign certificate for client  [root@docker-host2 ~]# openssl req -subj \u0026#34;/CN=docker-host1\u0026#34; -sha256 -new -key client-key.pem -out client.csr  Add info to cert  [root@docker-host2 ~]# vi extfile.cnf extendedKeyUsage = clientAuth  Generate client certificate  [root@docker-host2 ~]# openssl x509 -req -days 730 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out client-cert.pem -extfile extfile.cnf Signature ok subject=CN = docker-host1 Getting CA Private Key Enter pass phrase for ca-key.pem: Send generated keys and certificates I moved generated files to correct machines:\n client - docker-host1  ca.pem -\u0026gt; /home/lukas/.docker/ca.pem client-cert.pem -\u0026gt; /home/lukas/.docker/cert.pem client-key.pem -\u0026gt; /home/lukas/.docker/key.pem   daemon - docker-host3  ca.pem -\u0026gt; /home/lukas/.docker/ca.pem daemon-cert.pem -\u0026gt; /home/lukas/.docker/cert.pem daemon-key.pem -\u0026gt; /home/lukas/.docker/key.pem    It is important to change names properly as shown above.\nConfigure TLS Daemon On docker-host3 that will be daemon host - set TLS parameters in /etc/docker/daemon.json config file\n[root@docker-host3 ~]# vi /etc/docker/daemon.json { \u0026#34;hosts\u0026#34;: [\u0026#34;tcp://docker-host3:2376\u0026#34;], \u0026#34;tls\u0026#34;: true, \u0026#34;tlsverify\u0026#34;: true, \u0026#34;tlscacert\u0026#34;: \u0026#34;/home/lukas/.docker/ca.pem\u0026#34;, \u0026#34;tlscert\u0026#34;: \u0026#34;/home/lukas/.docker/cert.pem\u0026#34;, \u0026#34;tlskey\u0026#34;: \u0026#34;/home/lukas/.docker/key.pem\u0026#34; }  Important! hosts tells docker daemon to listen on IP docker-host3 on port 2376.\nThis option cant\u0026rsquo;t be use in docker config file if we have on host systemd.\nIf so, we have to edit docker.service with command: systemctl edit docker\nIn editor we have to add and save:\n[Service] ExecStart= ExecStart=/usr/bin/dockerd -H tcp://docker-host3:2376  Restart Docker\n[root@docker-host3 ~]# systemctl restart docker Check that docker listen on correct IP:Port\n[root@docker-host3 ~]# ps aux | grep docker root 1729 0.7 4.6 922864 87940 ? Ssl 22:38 0:00 /usr/bin/dockerd -H tcp://docker-host3:2376 root 1895 0.0 0.0 9180 968 pts/0 S+ 22:39 0:00 grep --color=auto docker From now at docker-host3 we can\u0026rsquo;t just use docker cli - IPC communication is now forbidden.\nWe can communicate by tcp - daemon insist on using TLS at client side:\n[root@docker-host3 ~]# docker -H tcp://docker-host3:2376 version Client: Docker Engine - Community Version: 19.03.8 API version: 1.40 Go version: go1.12.17 Git commit: afacb8b Built: Wed Mar 11 01:27:04 2020 OS/Arch: linux/amd64 Experimental: false Error response from daemon: Client sent an HTTP request to an HTTPS server. Client Set remote daemon location and check that without TLS we can\u0026rsquo;t connect\n[lukas@docker-host1 ~]# export DOCKER_HOST=tcp://docker-host3:2376 [lukas@docker-host1 ~]$ docker version Client: Docker Engine - Community Version: 19.03.8 API version: 1.40 Go version: go1.12.17 Git commit: afacb8b Built: Wed Mar 11 01:27:04 2020 OS/Arch: linux/amd64 Experimental: false Error response from daemon: Client sent an HTTP request to an HTTPS server. Activate TLS verification and check again that now we can connect securely\n[lukas@docker-host1 ~]# export DOCKER_TLS_VERIFY=1 [lukas@docker-host1 ~]$ docker version Client: Docker Engine - Community Version: 19.03.8 API version: 1.40 Go version: go1.12.17 Git commit: afacb8b Built: Wed Mar 11 01:27:04 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.8 API version: 1.40 (minimum version 1.12) Go version: go1.12.17 Git commit: afacb8b Built: Wed Mar 11 01:25:42 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 Remember to set exported variables in for example .bashrc for persistence.\nOptionally we can change path to cert and key by setting variable DOCKER_CERT_PATH\n","href":"/posts/docker_tls_secure_client_daemon/","title":"Docker TLS - secure client and daemon"},{"content":"","href":"/tags/security/","title":"security"},{"content":"","href":"/tags/tls/","title":"tls"},{"content":"Docker allows us to stream logs to different places with plugins called logging drivers.\nHow to change logging driver? What\u0026rsquo;s the most popular ones?\nWhat is logging driver? Docker has got two types of logging drivers:\n built-in like:  awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog   external drivers that we can install with docker plugin install  Logging driver is used to forward logs from containers to specific log aggregators, widely known rsyslog or fluentd for example.\nDefault logging driver after installation is json-file.\nIt is important to test non default logging drivers before using on production - problems with logging can cause crash/hang or startup problems with containers.\nCheck default logging driver This is driver that docker daemon will use for itself and containers that won\u0026rsquo;t have set explicit another driver at start\n[lukas@docker-host1 ~]$ docker info --format \u0026#39;{{.LoggingDriver}}\u0026#39; json-file Check logging driver for running container [lukas@docker-host1 docker]# docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7e0f1ab24716 httpd \u0026#34;httpd-foreground\u0026#34; About a minute ago Up About a minute 80/tcp web_server_httpd [lukas@docker-host1 docker]# docker inspect -f \u0026#39;{{.HostConfig.LogConfig.Type}}\u0026#39; web_server_httpd json-file Log location - container with json-file driver [lukas@docker-host1 docker]# docker container inspect web_server_httpd --format \u0026#34;{{.LogPath}}\u0026#34; /var/lib/docker/containers/7e0f1ab2471674b020f39a03e6c1cc49f8c70378acb5ca94d4323dc2cbeecb68/7e0f1ab2471674b020f39a03e6c1cc49f8c70378acb5ca94d4323dc2cbeecb68-json.log Logs from docker cli command This command will work fine with default \u0026lsquo;json-log\u0026rsquo; driver, can fail with non default ones\n[lukas@docker-host1 docker]# docker logs web_server_httpd AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.17.0.3. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.17.0.3. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message [Tue May 05 13:28:43.383499 2020] [mpm_event:notice] [pid 1:tid 140713807934592] AH00489: Apache/2.4.43 (Unix) configured -- resuming normal operations [Tue May 05 13:28:43.405939 2020] [core:notice] [pid 1:tid 140713807934592] AH00094: Command line: \u0026#39;httpd -D FOREGROUND\u0026#39; Set default logging driver We can set default log-driver in /etc/docker/daemon.json. Format:\n{ \u0026#34;log-driver\u0026#34;: \u0026#34;\u0026lt;log_driver_name\u0026gt;\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;\u0026lt;log_opt1_name\u0026gt;\u0026#34;: \u0026#34;\u0026lt;log_opt1_value\u0026gt;\u0026#34;, \u0026#34;\u0026lt;log_opt2_name\u0026gt;\u0026#34;: \u0026#34;\u0026lt;log_opt2_value\u0026gt;\u0026#34; } }  log_opts for json-file  max-size - max file size max-file - max number of files labels - list of keys of labels hat should be in log - if container has them set env - list of variables that should be in log - if container has them set   Change logging driver to journald [root@docker-host1 ~]# vi /etc/docker/daemon.json { \u0026#34;log-driver\u0026#34;: \u0026#34;journald } As in json-file we can optionally add another parameter log_opts to set some flags for journald driver:\n tag - Use to change CONTAINER_TAG and SYSLOG_IDENTIFIER labels - list of keys of labels hat should be in log - if container has them set env\t-\tlist of variables that should be in log - if container has them set  After configuration change we should restart docker daemon:\n[root@docker-host1 ~]# systemctl restart docker After starting container we can check his logs with journalctl command\n[lukas@docker-host1 ~]# docker run -d --name web_server_httpd httpd [lukas@docker-host1 ~]# journalctl CONTAINER_NAME=web_server_httpd -- Logs begin at Tue 2020-05-05 16:08:42 CEST, end at Tue 2020-05-05 16:12:28 CEST. -- May 05 16:12:28 docker-host1.lukas.int 5c331ed1a91b[1752]: AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.17.0.2. Set the \u0026gt; May 05 16:12:28 docker-host1.lukas.int 5c331ed1a91b[1752]: AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 172.17.0.2. Set the \u0026gt; May 05 16:12:28 docker-host1.lukas.int 5c331ed1a91b[1752]: [Tue May 05 14:12:28.492926 2020] [mpm_event:notice] [pid 1:tid 140110908605568] AH00489: Apache/2.4.43 (Unix) co\u0026gt; May 05 16:12:28 docker-host1.lukas.int 5c331ed1a91b[1752]: [Tue May 05 14:12:28.517394 2020] [core:notice] [pid 1:tid 140110908605568] AH00094: Command line: \u0026#39;httpd -D FORE\u0026gt; Your non priliged user should be in systemd-journal OS group to use journalctl command\nSet logging driver at container level We have now as default configured journald - but we can override this when starting container\n[lukas@docker-host1 ~]$ docker run -d --name web_server --log-driver json-file httpd 9427635d3943c2cf7fa48f0fe82f00b06bd5026619151437858ec9d40bc1b7ad We can also set options for driver with --log-opt followed by \u0026lt; key \u0026gt;=\u0026lt; value \u0026gt;.\nFor multiple flags we add multiple --log-opt params.\n","href":"/posts/docker_logging_driver/","title":"Docker logging driver configuration - json-file and journald"},{"content":"","href":"/tags/docker-logs/","title":"docker logs"},{"content":"","href":"/tags/log-driver/","title":"log-driver"},{"content":"Install and upgrade of Docker Engine is simple and straightforward process.\nIn this post I will cover all important information in one place.\nDocker install requirements Minimum requirements\n 8GB RAM per manager node 4GB RAM per worker node 3GB of free disk space  Recommended production requirements\n 16GB RAM per manager node 4 vCPUs per manager node 25-100GB of free disk space on each node  Also you must have one of the following OS:\n CentOS 7.1+ 64 bit version Ubuntu 16.04/18.04/19.10 64 bit versions  Preferable storage driver on newer OS is overlay2.\nDocker engine will set it by default.\nIf you want to get to know what is storage driver, what storage drivers are advised on certain OS and how to change it or looking for detailed info about setup of devicemapper, look at:\nDocker storage driver - guide \nDocker devicemapper - setup\n Important If you plan to use Docker Enterprise with multiple nodes or Swarm - remember to set up time synchro between nodes - use NTP for that.\n Docker install CentOS  Ensure that centos-extras repo is enabled Install yum-utils:  yum install -y yum-utils  Add repo  yum-config-manager \\  --add-repo \\  https://download.docker.com/linux/centos/docker-ce.repo  Install docker engine(Valid GPG Key: 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35)  yum install docker-ce docker-ce-cli containerd.io CentOS 8 at day of writing this post has problem with dependiences for containerd.io - you can solve this by installing manually correct version of containerd.io before running docker-ce instalation command. Example\nyum install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm  Start and enable autostart of daemon:  systemctl start docker systemctl enable docker Optionally you can list available versions of docker and install preferable one:\nyum list docker-ce --showduplicates | sort -r yum install docker-ce-\u0026lt;VERSION_STRING\u0026gt; docker-ce-cli-\u0026lt;VERSION_STRING\u0026gt; containerd.io  For installing Docker Enterprise Edition you have to set up repo on your OS after getting from Docker Hub Account Docker EE Repo Adress.\n Docker install Ubuntu  Update system and install important packages  apt-get update apt-get install \\  apt-transport-https \\  ca-certificates \\  curl \\  gnupg-agent \\  software-properties-common  Add GPG Key(fingerprint: 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88)  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  Add repo  add-apt-repository \\  \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs)\\ stable\u0026#34;  Install docker engine  apt-get update apt-get install docker-ce docker-ce-cli containerd.io Optionally check available versions:\napt-cache madison docker-ce And install specific one:\napt-get install docker-ce=\u0026lt;VERSION_STRING\u0026gt; docker-ce-cli=\u0026lt;VERSION_STRING\u0026gt; containerd.io Docker upgrade Live restore If you want that running containers won\u0026rsquo;t stop with docker daemon you can enable live restore feature. After enabling it you can perform upgrade of docker engine without stopping running containers.\nIn /etc/docker/daemon.json set:\n{ \u0026#34;live-restore\u0026#34;: true } Upgrade on CentOS or Ubuntu - if we install docker engine from repo - can be performed with simple yum upgrade or apt-get upgrade commands.\n","href":"/posts/docker_install_upgrade/","title":"Docker install and upgrade guide - CentOS and Ubuntu"},{"content":"","href":"/tags/docker-swarm/","title":"docker swarm"},{"content":"For HA and easier management of our containers we can create swarm cluster.\nIt is composed of couple nodes with docker engine installed.\nHow to setup swarm and use it?\nExample configuration and prerequisites In my lab environment I used three nodes:\n   Role in Swarm Server IP     Manager docker-host1.lukas.int 10.10.10.20   Worker1 docker-host2.lukas.int 10.10.10.21   Worker2 docker-host3.lukas.int 10.10.10.22    Each node has got docker engine installed with standard procedure as for single node docker.\nPorts that are need to be open on each node:\n   TCP/UDP Port What is for?     TCP 2377 cluster management   TCP and UDP 7946 node communication   UDP 4789 overlay network    Create swarm cluster Log in to manager node.\nMost importatnt parameters for docker swarm init:\n --autolock - true or false - enable autolock for manager node - more later in this post --advertise-addr - address for API and overlay networks for other cluster members --listen-addr - address for cluster management --availability - cloud be active(new tasks allowed), pause(new tasks not allowed, but old keeps going) or drain(new tasks not allowed, finish immediately old ones if they exists) - set drain for manager node to create manager without containers on it --default-addr-pool - by default 10.10.10.0/8 - we can set another address pool for overlay network created with cluster --default-addr-pool-mask-len - number on subnets that are allow to be created in --default-addr-pool  [lukas@docker-host1 ~]$ docker swarm init --advertise-addr 10.10.10.20 --listen-addr 10.10.10.20 Swarm initialized: current node (x7mdjbmfz3ttkxbvelriix4yz) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-0zwqchv43d2alvl99fgw2mh6cnv7xc8vakspd90yjh4i7eiwwx-cn32plktlwjf8q25azk37ij5v 10.10.10.20:2377 To add a manager to this swarm, run \u0026#39;docker swarm join-token manager\u0026#39; and follow the instructions. In output we get command to add worker node to cluster.\n Get tokens for adding nodes to cluster If we need tokens later and we didn\u0026rsquo;t write them down we can get them from any manager node.\nManager token [lukas@docker-host1 ~]$ docker swarm join-token manager To add a manager to this swarm, run the following command: docker swarm join --token SWMTKN-1-0zwqchv43d2alvl99fgw2mh6cnv7xc8vakspd90yjh4i7eiwwx-956h96o5ivrekolr42k71bgqc 10.10.10.20:2377 Worker command [lukas@docker-host1 ~]$ docker swarm join-token worker To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-0zwqchv43d2alvl99fgw2mh6cnv7xc8vakspd90yjh4i7eiwwx-cn32plktlwjf8q25azk37ij5v 10.10.10.20:2377 Important! Tokens should be secured well, they give access to cluster.\nIf they leaked somewhere, we should change them with command(we can rotate for worker or manager):\n[lukas@docker-host1 ~]$ docker swarm join-token --rotate worker Successfully rotated worker join token. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-0zwqchv43d2alvl99fgw2mh6cnv7xc8vakspd90yjh4i7eiwwx-c7r78dy7kwho1zq3uq7w26xhl 10.10.10.20:2377  Add workers I will add my docker-host2 and docker-host3 as workers.\n[lukas@docker-host2 ~]$ docker swarm join --token SWMTKN-1-0zwqchv43d2alvl99fgw2mh6cnv7xc8vakspd90yjh4i7eiwwx-cn32plktlwjf8q25azk37ij5v 10.10.10.20:2377 This node joined a swarm as a worker. [lukas@docker-host3 ~]$ docker swarm join --token SWMTKN-1-0zwqchv43d2alvl99fgw2mh6cnv7xc8vakspd90yjh4i7eiwwx-cn32plktlwjf8q25azk37ij5v 10.10.10.20:2377 This node joined a swarm as a worker. List nodes We can see that manager node is named as leader.\nListing is available only from manager node.\n[lukas@docker-host1 ~]$ docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION x7mdjbmfz3ttkxbvelriix4yz * docker-host1.lukas.int Ready Active Leader 19.03.8 va779vfr6v115025a15yvuntv docker-host2.lukas.int Ready Active 19.03.8 k61h5c7sqzjepifp6lzjxpr95 docker-host3.lukas.int Ready Active 19.03.8 What each type of node do? Manager  sends tasks to worker nodes(or manager nodes also if we allow container there) sends heartbeat to nodes in cluster to be current with cluster state serves API for management  It is strongly recommended to have at least three manager nodes in production cluster for HA. This configuration will survive lost of one manager node.\nIn such configuration still only one of managers will be leader, rest will replicates data from him and waits for his breakdown.\nWorker This type of nodes only hosts scheduled containers.\nIt can by promoted to manager with docker node promote command.\nInspect node details [lukas@docker-host1 ~]$ docker node inspect docker-host2.lukas.int --pretty ID:\tva779vfr6v115025a15yvuntv Hostname: docker-host2.lukas.int Joined at: 2020-04-24 13:44:41.431444118 +0000 utc Status: State:\tReady Availability: Active Address:\t10.10.10.21 Platform: Operating System:\tlinux Architecture:\tx86_64 Resources: CPUs:\t2 Memory:\t1.786GiB Plugins: Log:\tawslogs, fluentd, gcplogs, gelf, journald, json-file, local, logentries, splunk, syslog Network:\tbridge, host, ipvlan, macvlan, null, overlay Volume:\tlocal Engine Version:\t19.03.8 TLS Info: TrustRoot: -----BEGIN CERTIFICATE----- \u0026lt;cert here\u0026gt; -----END CERTIFICATE----- Issuer Subject:\tMBMxETAPBgNVBAMTCHN3YXJtLWNh Issuer Public Key:\t\u0026lt;public key here\u0026gt; Without --pretty flag we get raw json describing node. We can get exact information from it with --format flag.\nCheck node role [lukas@docker-host1 ~]$ docker inspect docker-host1.lukas.int --format \u0026#34;{{.Spec.Role}}\u0026#34; manager Check node status [lukas@docker-host1 ~]$ docker inspect docker-host1.lukas.int --format \u0026#34;{{.Status.State}}\u0026#34; ready Changing node parameters [lukas@docker-host1 ~]$ docker node update --availability drain docker-host3.lukas.int docker-host3.lukas.int [lukas@docker-host1 ~]$ docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION x7mdjbmfz3ttkxbvelriix4yz * docker-host1.lukas.int Ready Active Leader 19.03.8 va779vfr6v115025a15yvuntv docker-host2.lukas.int Ready Active 19.03.8 k61h5c7sqzjepifp6lzjxpr95 docker-host3.lukas.int Ready Drain 19.03.8 Promoting/demoting node Promote [lukas@docker-host1 ~]$ docker node promote docker-host3.lukas.int Node docker-host3.lukas.int promoted to a manager in the swarm. [lukas@docker-host1 ~]$ docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION x7mdjbmfz3ttkxbvelriix4yz * docker-host1.lukas.int Ready Active Leader 19.03.8 va779vfr6v115025a15yvuntv docker-host2.lukas.int Ready Active 19.03.8 nqe3eyk55lvmwsmqy5lx8v8vx docker-host3.lukas.int Ready Active Reachable 19.03.8 Demote [lukas@docker-host1 ~]$ docker node demote docker-host3.lukas.int Manager docker-host3.lukas.int demoted in the swarm. Leave cluster From leaving node:\n[lukas@docker-host2 ~]$ docker swarm leave Node left the swarm. It is possible to use flag --force if you want evict manager node.\nFrom manager - node that will be removed should be shutted down before:\n[lukas@docker-host1 ~]$ docker node rm docker-host2.lukas.int docker-host2.lukas.int Locking swarm cluster All managers of swarm has got copy of TLS encryption keys.\nIf we want to protect these keys we can enable autolock feature.\nWhen enabled, after node restart his configuration data needs to be decrypted with special key before starting any service on it.\nEnable autolock You can enable autolock at cluster initialization with docker swarm init or later with docker swarm update.\n[lukas@docker-host1 ~]$ docker swarm update --autolock=true Swarm updated. To unlock a swarm manager after it restarts, run the `docker swarm unlock` command and provide the following key: SWMKEY-1-fFGBM6X97rFMI/2NHn3meJGH+j5lhLT1VnzgeQcZBAU Please remember to store this key in a password manager, since without it you will not be able to restart the manager. Testing autolock I will promote docker-host2.lukas.int to manager.\n[lukas@docker-host1 ~]$ docker node promote docker-host2.lukas.int Node docker-host2.lukas.int promoted to a manager in the swarm. [lukas@docker-host1 ~]$ docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION x7mdjbmfz3ttkxbvelriix4yz * docker-host1.lukas.int Ready Active Leader 19.03.8 va779vfr6v115025a15yvuntv docker-host2.lukas.int Ready Active Reachable 19.03.8 nqe3eyk55lvmwsmqy5lx8v8vx docker-host3.lukas.int Ready Active 19.03.8 Restart docker-host2.lukas.int - only docker daemon - will be enough.\n[root@docker-host2 ~]# systemctl restart docker Check any docker command on docker-host2.lukas.int.\n[lukas@docker-host2 ~]$ docker node ls Error response from daemon: Swarm is encrypted and needs to be unlocked before it can be used. Please use \u0026#34;docker swarm unlock\u0026#34; to unlock it. Unlock with key generated before:\n[lukas@docker-host2 ~]$ docker swarm unlock Please enter unlock key: Check if node started correctly:\n[lukas@docker-host2 ~]$ docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION x7mdjbmfz3ttkxbvelriix4yz docker-host1.lukas.int Ready Active Leader 19.03.8 va779vfr6v115025a15yvuntv * docker-host2.lukas.int Ready Active Reachable 19.03.8 nqe3eyk55lvmwsmqy5lx8v8vx docker-host3.lukas.int Ready Active 19.03.8 Check unlock key [lukas@docker-host1 ~]$ docker swarm unlock-key To unlock a swarm manager after it restarts, run the `docker swarm unlock` command and provide the following key: SWMKEY-1-fFGBM6X97rFMI/2NHn3meJGH+j5lhLT1VnzgeQcZBAU Please remember to store this key in a password manager, since without it you will not be able to restart the manager. Rotate key [lukas@docker-host1 ~]$ docker swarm unlock-key --rotate Successfully rotated manager unlock key. To unlock a swarm manager after it restarts, run the `docker swarm unlock` command and provide the following key: SWMKEY-1-RsrHxoajv/57yi9Eng7SDcDS7TGxcWI0MqKrpMTlpWs Please remember to store this key in a password manager, since without it you will not be able to restart the manager. Swarm Services All operations on swarm services will be done from manager node.\nCreate service If you plan to create service with image from login-secured registry, you should first login:\n[lukas@docker-host1 ~]$ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don\u0026#39;t have a Docker ID, head over to https://hub.docker.com to create one. Username: \u0026lt;username\u0026gt; Password: \u0026lt;password\u0026gt; WARNING! Your password will be stored unencrypted in /home/lukas/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Then you can crate service with optional --with-registry-auth flag - docker client will copy your authentication information securely to all nodes that will be pulling image for your service.\n Important! It is strongly advised to not use images names without tag or with latest tag.\nWhen Swarm is creating service it resolves name of image and tag into digest hash, from that moment in service configuration resides only hash pointing to image that was tagged latest at moment of issuing docker service create command.\nUsing latest tag in service description can lead to mistakes because of fact, that latest tag moves always to newest software version.\nAlways use explicit images names like ubuntu:19.04\n We will create docker service named web_server, there will be two containers deployed around our docker swarm cluster, each of this containers will expose his port 80 on 80 port of docker host machine(it is important to check that port is available on every docker host from swarm cluster).\nContainers will be hosting Apache version 2.4\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --replicas=2 --publish 80:80 httpd:2.4 h6ttr4yuoukc8zhwo4a5oin33 overall progress: 2 out of 2 tasks 1/2: running [==================================================\u0026gt;] 2/2: running [==================================================\u0026gt;] verify: Service converged As in docker run we can add parameters that will change containers start behaviour or override some image settings like:\n --dns --entrypoint --env --workdir --user  Full list available with command docker service create -h.\n Templating service When creating service there is possibility to set some parameters to contaiers based on service metadata.\nParameters that we can use with templates:\n --hostname - set hostname for containers --mount - mount volumes --env - set environment variables in containers runtime  Possible templates:\n .Service.ID .Service.Name .Service.Labels .Node.ID .Node.Hostname .Task.Name .Task.Slot  We want to set hostname in containers that it will correspond to service name:\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --replicas=6 --publish target=80,published=80 --hostname=\u0026#34;{{.Node.ID}}-{{.Service.Name}}\u0026#34; httpd:2.4 x0zrp0zkls6v3wfue39638lev overall progress: 6 out of 6 tasks 1/6: running [==================================================\u0026gt;] 2/6: running [==================================================\u0026gt;] 3/6: running [==================================================\u0026gt;] 4/6: running [==================================================\u0026gt;] 5/6: running [==================================================\u0026gt;] 6/6: running [==================================================\u0026gt;] verify: Service converged Check hostname of random container:\n[lukas@docker-host2 ~]$ docker exec -it f3cd22cef724 bash root@va779vfr6v115025a15yvuntv-web_server:/usr/local/apache2# hostname va779vfr6v115025a15yvuntv-web_server  List services [lukas@docker-host1 ~]$ docker service ls ID NAME MODE REPLICAS IMAGE PORTS h6ttr4yuoukc web_server replicated 2/2 httpd:2.4 *:80-\u0026gt;80/tcp List service details [lukas@docker-host1 ~]$ docker service ps h6ttr4yuoukc ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS zdv7uqomaz29 web_server.1 httpd:2.4 docker-host3.lukas.int Running Running about a minute ago fe36zt5e5zsz web_server.2 httpd:2.4 docker-host2.lukas.int Running Running 59 seconds ago Check service response - ingress mode We can easily test apache with curl and GET method.\n[lukas@docker-host1 ~]$ curl -X GET 127.0.0.1:80 \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;It works!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; [lukas@docker-host2 ~]$ curl -X GET 127.0.0.1:80 \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;It works!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; [lukas@docker-host3 ~]$ curl -X GET 127.0.0.1:80 \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;It works!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; As we see despite that containers are only on docker-host2 and docker-host3 machines - service that they serve is available on every node in cluster at port 80. This is default called ingress mode - all calls on port 80 on every node in swarm cluster are redirected automatically to nodes with containers serving service.\nSet port publishing in host mode If you want to publish ports of service only on nodes where containers from services resides you should deploy it with mode=host parameter in --publish flag.\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --replicas=2 --publish mode=host,target=80,published=80 httpd:2.4 s7qjpd70u19ttk49jbgu647p5 overall progress: 2 out of 2 tasks 1/2: running [==================================================\u0026gt;] 2/2: running [==================================================\u0026gt;] verify: Service converged [lukas@docker-host1 ~]$ docker service ps s7qjpd70u19t ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS tic5zzp4s0ry web_server.1 httpd:2.4 docker-host2.lukas.int Running Running 33 seconds ago *:80-\u0026gt;80/tcp bjz1zlnpxh1v web_server.2 httpd:2.4 docker-host3.lukas.int Running Running 33 seconds ago *:80-\u0026gt;80/tcp Let\u0026rsquo;s check where we can connect to our service.\n[lukas@docker-host1 ~]$ curl -X GET 127.0.0.1:80 curl: (7) Failed to connect to 127.0.0.1 port 80: Connection refused [lukas@docker-host2 ~]$ curl -X GET 127.0.0.1:80 \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;It works!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; [lukas@docker-host3 ~]$ curl -X GET 127.0.0.1:80 \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;It works!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; As we see, ports are available only on nodes with containers.\nMount volumes As in standard container, in swarm we can create volumes with --mount flag.\nWe mount site_content in /var/html/www location in every container.\nThis volume was not created earlier so docker will create it by himself.\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --replicas=6 --publish target=80,published=80 --mount source=site_content,target=/var/html/www httpd:2.4 fim71hxxnzic4pn9trwh77sjt overall progress: 6 out of 6 tasks 1/6: running [==================================================\u0026gt;] 2/6: running [==================================================\u0026gt;] 3/6: running [==================================================\u0026gt;] 4/6: running [==================================================\u0026gt;] 5/6: running [==================================================\u0026gt;] 6/6: running [==================================================\u0026gt;] verify: Service converged I created six replicas to show interesting thing - we have three node cluster - so it is highly probable that on some node will be more than one container.\nHow many volumes will be created?\n[lukas@docker-host2 ~]$ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b5cb6f86ba06 httpd:2.4 \u0026#34;httpd-foreground\u0026#34; 16 seconds ago Up 11 seconds 80/tcp web_server.3.6b9hgq4cjz90aaufplpjt61er 262af192ced6 httpd:2.4 \u0026#34;httpd-foreground\u0026#34; 16 seconds ago Up 11 seconds 80/tcp web_server.6.mmkia5wsc7trnaqv9ozil3h0b [lukas@docker-host2 ~]$ docker volume ls DRIVER VOLUME NAME local site_content Exactly one! Service assume that all containers in it do the same, if there will be more that one container per node - these containers will have common volume.\nIt is important to remember about this behaviour.\nConnect services to networks Create network if you don\u0026rsquo;t have one:\n[lukas@docker-host1 ~]$ docker network create --driver overlay management_network brgzvb0gxkb6y8q9mgb4rurwu [lukas@docker-host1 ~]$ docker network ls NETWORK ID NAME DRIVER SCOPE [...] tverx8ooqine ingress overlay swarm brgzvb0gxkb6 management_network overlay swarm Create service with --network flag:\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --replicas=2 --publish target=80,published=80 --network management_network httpd:2.4 tbojbrsx89nukjh58vvknru1t overall progress: 2 out of 2 tasks 1/2: running [==================================================\u0026gt;] 2/2: running [==================================================\u0026gt;] verify: Service converged Check from node with one of containers that they are connected to additional network:\n[lukas@docker-host2 ~]$ docker inspect b8c2037f5235 [ { \u0026#34;Id\u0026#34;: \u0026#34;b8c2037f5235515c464e2af9444ab252efd080e1fa23fc0595f22c4a201ef760\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-04-27T14:29:57.718762759Z\u0026#34;, \u0026#34;Path\u0026#34;: \u0026#34;httpd-foreground\u0026#34;, [...] \u0026#34;Networks\u0026#34;: { [...] \u0026#34;management_network\u0026#34;: { \u0026#34;IPAMConfig\u0026#34;: { \u0026#34;IPv4Address\u0026#34;: \u0026#34;10.0.1.3\u0026#34; }, \u0026#34;Links\u0026#34;: null, \u0026#34;Aliases\u0026#34;: [ \u0026#34;b8c2037f5235\u0026#34; ], \u0026#34;NetworkID\u0026#34;: \u0026#34;brgzvb0gxkb6y8q9mgb4rurwu\u0026#34;, \u0026#34;EndpointID\u0026#34;: \u0026#34;3b94e38428228bb764954b5619d928ad64a26a37cc06010741fcd7ddff9c7e61\u0026#34;, \u0026#34;Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;IPAddress\u0026#34;: \u0026#34;10.0.1.3\u0026#34;, \u0026#34;IPPrefixLen\u0026#34;: 24, \u0026#34;IPv6Gateway\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6Address\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;GlobalIPv6PrefixLen\u0026#34;: 0, \u0026#34;MacAddress\u0026#34;: \u0026#34;02:42:0a:00:01:03\u0026#34;, \u0026#34;DriverOpts\u0026#34;: null  For more information about network configuraion in Docker Swarm look at:\nDocker Network - complete guide\n Global service By then we was creating services in replicated mode where we set exact number of replicas.\nIf we want to have service containers on all available nodes of our cluster then we should run in with --mode=global.\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --mode=global --publish target=80,published=80 httpd:2.4 wh27xrc33f515f8ccjkfqmhpw overall progress: 3 out of 3 tasks va779vfr6v11: running [==================================================\u0026gt;] nqe3eyk55lvm: running [==================================================\u0026gt;] x7mdjbmfz3tt: running [==================================================\u0026gt;] verify: Service converged [lukas@docker-host1 ~]$ docker service ps wh27xrc33f515f8ccjkfqmhpw ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS wop37gk76oy1 web_server.x7mdjbmfz3ttkxbvelriix4yz httpd:2.4 docker-host1.lukas.int Running Running 21 seconds ago dfgkhs7js37r web_server.va779vfr6v115025a15yvuntv httpd:2.4 docker-host2.lukas.int Running Running 23 seconds ago wgsf8plhlghg web_server.nqe3eyk55lvmwsmqy5lx8v8vx httpd:2.4 docker-host3.lukas.int Running Running 23 seconds ago Test global service bahaviour Let\u0026rsquo;s check what will happen when we remove node from cluster.\nFor simplicity I will set node into drain mode described earlier.\n[lukas@docker-host1 ~]$ docker node update --availability drain docker-host3.lukas.int docker-host3.lukas.int Check service status - container on drained node is shutdown state:\n[lukas@docker-host1 ~]$ docker service ps wh27xrc33f515f8ccjkfqmhpw ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS wop37gk76oy1 web_server.x7mdjbmfz3ttkxbvelriix4yz httpd:2.4 docker-host1.lukas.int Running Running 3 minutes ago dfgkhs7js37r web_server.va779vfr6v115025a15yvuntv httpd:2.4 docker-host2.lukas.int Running Running 3 minutes ago wgsf8plhlghg web_server.nqe3eyk55lvmwsmqy5lx8v8vx httpd:2.4 docker-host3.lukas.int Shutdown Shutdown 1 second ago Now we can make our node available again:\n[lukas@docker-host1 ~]$ docker node update --availability active docker-host3.lukas.int docker-host3.lukas.int Check service - global service as soon as node became available start new container on it:\n[lukas@docker-host1 ~]$ docker service ps wh27xrc33f515f8ccjkfqmhpw ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS k7l2nnjstjkn web_server.nqe3eyk55lvmwsmqy5lx8v8vx httpd:2.4 docker-host3.lukas.int Running Running less than a second ago wop37gk76oy1 web_server.x7mdjbmfz3ttkxbvelriix4yz httpd:2.4 docker-host1.lukas.int Running Running 3 minutes ago dfgkhs7js37r web_server.va779vfr6v115025a15yvuntv httpd:2.4 docker-host2.lukas.int Running Running 3 minutes ago wgsf8plhlghg web_server.nqe3eyk55lvmwsmqy5lx8v8vx httpd:2.4 docker-host3.lukas.int Shutdown Shutdown 16 seconds ago Set specified nodes for containers If we have got couple of nodes in our cluster but want to run service on specific ones, we can use node labeling - placement constraints.\nSet label workload_type=web on node:\n[lukas@docker-host1 ~]$ docker node update --label-add workload_type=web docker-host3.lukas.int Check labels on node:\n[lukas@docker-host1 ~]$ docker node inspect --format \u0026#39;{{ .Spec.Labels }}\u0026#39; docker-host1.lukas.int map[workload_type:web]  For labeling, we can use any key and value that we want.\nThere is no dictionary of available keys.\n Run service with flag --constraint node.labels.workload_type==web:\n[lukas@docker-host1 ~]$ docker service create --with-registry-auth --name web_server --replicas=2 --publish target=80,published=80 --constraint node.labels.workload_type==web httpd:2.4 idj6xxlcndqztnaxz2fvn7n5k overall progress: 2 out of 2 tasks 1/2: running [==================================================\u0026gt;] 2/2: running [==================================================\u0026gt;] verify: Service converged We want replica mode service with two replicas. Only docker-host3 has got label on it, so both replicas will be started on this node.\n[lukas@docker-host1 ~]$ docker service ps idj6xxlcndqztnaxz2fvn7n5k ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 2wrrvkgtbjks web_server.1 httpd:2.4 docker-host3.lukas.int Running Running 13 seconds ago 7z81ske7htq0 web_server.2 httpd:2.4 docker-host3.lukas.int Running Running 13 seconds ago Scale service Update number of replicas:\n[lukas@docker-host1 ~]$ docker service scale web_server=2 web_server scaled to 2 overall progress: 2 out of 2 tasks 1/2: running [==================================================\u0026gt;] 2/2: running [==================================================\u0026gt;] verify: Service converged Update service Set update preferences If you want to edit service with docker service update command docker will do that by restarting containers.\nYou can configure how restarting procedure will look like with docker service create or docker service update flags:\n --update-delay - time gap between restarting next containers batch --update-parallelism - number of containers in batch - by default: 1 --update-failure-action - what to do on failure in container update process - by default: pause - we can set there continue --update-max-failure-ratio - value from 0 to 1 - how many containers can fail during update process - 0.1 is considered like 10%  Setting some update preferences to service will not restart any containers.\n[lukas@docker-host1 ~]$ docker service update --update-delay 5s --update-parallelism 2 web_server web_server overall progress: 6 out of 6 tasks 1/6: running [==================================================\u0026gt;] 2/6: running [==================================================\u0026gt;] 3/6: running [==================================================\u0026gt;] 4/6: running [==================================================\u0026gt;] 5/6: running [==================================================\u0026gt;] 6/6: running [==================================================\u0026gt;] verify: Service converged You can check current preferences with docker service inspect command:\n[lukas@docker-host1 ~]$ docker service inspect web_server [...] \u0026#34;UpdateConfig\u0026#34;: { \u0026#34;Parallelism\u0026#34;: 2, \u0026#34;Delay\u0026#34;: 5000000000, \u0026#34;FailureAction\u0026#34;: \u0026#34;pause\u0026#34;, \u0026#34;Monitor\u0026#34;: 5000000000, \u0026#34;MaxFailureRatio\u0026#34;: 0, \u0026#34;Order\u0026#34;: \u0026#34;stop-first\u0026#34; }, [...] Update examples Add port publishing [lukas@docker-host1 ~]$ docker service update --publish-add 80 web_server web_server overall progress: 2 out of 6 tasks 1/6: running [==================================================\u0026gt;] 2/6: running [==================================================\u0026gt;] 3/6: ready [======================================\u0026gt; ] 4/6: ready [======================================\u0026gt; ] 5/6: 6/6: Remove port publishing [lukas@docker-host1 ~]$ docker service update --publish-rm 80 web_server web_server overall progress: 0 out of 6 tasks 1/6: ready [======================================\u0026gt; ] 2/6: 3/6: ready [======================================\u0026gt; ] 4/6: 5/6: 6/6: Add network [lukas@docker-host1 ~]$ docker service update --network-add management_network web_server web_server overall progress: 2 out of 6 tasks 1/6: running [==================================================\u0026gt;] 2/6: running [==================================================\u0026gt;] 3/6: preparing [=================================\u0026gt; ] 4/6: ready [======================================\u0026gt; ] 5/6: 6/6: Remove network [lukas@docker-host1 ~]$ docker service update --network-rm management_network web_server web_server overall progress: 0 out of 6 tasks 1/6: ready [======================================\u0026gt; ] 2/6: 3/6: 4/6: ready [======================================\u0026gt; ] 5/6: 6/6: Rollback service To rollback last change we can use docker service update --rollback.\nRollback example [lukas@docker-host1 ~]$ docker service update --rollback web_server web_server rollback: manually requested rollback overall progress: rolling back update: 0 out of 6 tasks 1/6: 2/6: 3/6: 4/6: starting [=====\u0026gt; ] 5/6: 6/6: Check logs for service [lukas@docker-host1 ~]$ docker service logs web_server web_server.1.ogwy5n7dgw6l@docker-host2.lukas.int | AH00557: httpd: apr_sockaddr_info_get() failed for 2c910786bf88 web_server.1.ogwy5n7dgw6l@docker-host2.lukas.int | AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 127.0.0.1. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message web_server.1.ogwy5n7dgw6l@docker-host2.lukas.int | AH00557: httpd: apr_sockaddr_info_get() failed for 2c910786bf88 web_server.1.ogwy5n7dgw6l@docker-host2.lukas.int | AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 127.0.0.1. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message web_server.1.ogwy5n7dgw6l@docker-host2.lukas.int | [Tue Apr 28 11:53:36.436335 2020] [mpm_event:notice] [pid 1:tid 139739008033920] AH00489: Apache/2.4.43 (Unix) configured -- resuming normal operations web_server.1.ogwy5n7dgw6l@docker-host2.lukas.int | [Tue Apr 28 11:53:36.436683 2020] [core:notice] [pid 1:tid 139739008033920] AH00094: Command line: \u0026#39;httpd -D FOREGROUND\u0026#39; web_server.2.kz0f5nire5az@docker-host3.lukas.int | AH00557: httpd: apr_sockaddr_info_get() failed for e39d1978f0fc web_server.2.kz0f5nire5az@docker-host3.lukas.int | AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 127.0.0.1. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message web_server.2.kz0f5nire5az@docker-host3.lukas.int | AH00557: httpd: apr_sockaddr_info_get() failed for e39d1978f0fc web_server.2.kz0f5nire5az@docker-host3.lukas.int | AH00558: httpd: Could not reliably determine the server\u0026#39;s fully qualified domain name, using 127.0.0.1. Set the \u0026#39;ServerName\u0026#39; directive globally to suppress this message web_server.2.kz0f5nire5az@docker-host3.lukas.int | [Tue Apr 28 11:53:36.571678 2020] [mpm_event:notice] [pid 1:tid 140383257580672] AH00489: Apache/2.4.43 (Unix) configured -- resuming normal operations web_server.2.kz0f5nire5az@docker-host3.lukas.int | [Tue Apr 28 11:53:36.572014 2020] [core:notice] [pid 1:tid 140383257580672] AH00094: Command line: \u0026#39;httpd -D FOREGROUND\u0026#39; Remove service [lukas@docker-host1 ~]$ docker service rm web_server web_server ","href":"/posts/docker_swarm_compendium/","title":"Docker swarm - setup and usage"},{"content":"","href":"/tags/docker-bind-mount/","title":"docker bind mount"},{"content":"","href":"/tags/docker-volume/","title":"docker volume"},{"content":"Storing persistent data in containers needs special storage. There is two options - volumes or bind mounts.\nHow to use them?\nVolume vs bind mounts Bind mounts:\n rely on docker host directory structure different behaviour for --mount and --volume parameters cant\u0026rsquo; be control by docker CLI used mainly in development environments  Volumes:\n can be control by docker CLI works in Linux and Windows hosts easier to backup because of central location /var/lib/docker/volumes easier to store in cloud provider infrastructure preferred method as docker documentation said give possibility to be shared between cluster nodes  At newer versions of Docker preferred method for configuring is --mount parameter instead of --volume.\nVolume usage Create volume [lukas@docker-host ~]$ docker volume create lukas-space lukas-space List volumes [root@docker-host ~]# docker volume ls DRIVER VOLUME NAME local lukas-space Check volume physical location [lukas@docker-host ~]$ docker volume inspect lukas-space [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2020-04-22T14:06:33+02:00\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: {}, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/lukas-space/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;lukas-space\u0026#34;, \u0026#34;Options\u0026#34;: {}, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] Driver local means that we didn\u0026rsquo;t use any external driver to create volume, it resides on docker host local storage.\nExternal drivers will be covered in another post.\nAt docker host from root:\n[root@docker-host ~]# ls -lah /var/lib/docker/volumes/lukas-space/_data total 0 drwxr-xr-x. 2 root root 6 Apr 22 14:06 . drwxr-xr-x. 3 root root 19 Apr 22 14:06 .. Start container with created volume Parameter --mount has following options:\n type - volume(default), bind mount or tmpfs source - name of volume target - location in container filesystem where volume should be mounted optionally readonly option  Options have to be delimited by comma.\nWe want to mount lukas-space volume at /lukas-space directory in read-write mode:\n[lukas@docker-host ~]$ docker run -it --name ubuntu-server --mount source=lukas-space,target=/lukas-space ubuntu bash  Important!  if we didn\u0026rsquo;t create volume earlier docker will create it for us with name given in source field of --mount parameter volumes by default will not be deleted while we removing container if volume should be deleted with container - add --rm option to docker run command if container has got in target directory any files, this files will be copied into volume   Check if mounted directory exists:\nroot@7d7887833e93:/# ls -lah /lukas-space/ total 0 drwxr-xr-x. 2 root root 22 Apr 22 12:23 . drwxr-xr-x. 22 root root 261 Apr 22 12:24 .. Create test file:\nroot@be1874c33798:/# touch /lukas-space/testfile Check from docker host level that file appears:\n[root@docker-host ~]# ls -lah /var/lib/docker/volumes/lukas-space/_data total 0 drwxr-xr-x. 2 root root 22 Apr 22 14:23 . drwxr-xr-x. 3 root root 19 Apr 22 14:06 .. -rw-r--r--. 1 root root 0 Apr 22 14:23 testfile You can make from this location backup or restore of volume data.\nBind mount usage Create directory to mount [lukas@docker-host ~]$ mkdir bindmount Create container with directory mounted:\n[lukas@docker-host ~]$ docker run -it --name ubuntu-server --mount type=bind,source=/home/lukas/bindmount,target=/lukas-space ubuntu bash root@41cd34d22b7d:/# ls -lah /lukas-space/ total 0 drwxrwxr-x. 2 1000 1000 6 Apr 22 13:26 . drwxr-xr-x. 22 root root 261 Apr 22 13:27 ..  Important!  if we didn\u0026rsquo;t create directory on docker host earlier docker will not create it for us with --mount parameter, auto-creating is available only in older --volume bind mounts by default will not be deleted while we removing container if container has got in target directory any files, this files will NOT be copied into bind mount directory, bind directory will cover any files in target container directory   ","href":"/posts/docker_volume_bind_mounts/","title":"Docker volumes and bind mounts"},{"content":"","href":"/tags/devicemapper/","title":"devicemapper"},{"content":"If you are searching for better manageability of storage layer under your docker images and container you should consider devicemapper storage driver.\nIt gives you ability to use block device instead of standard file based storage.\nConfigure devicemapper with lvm as storage driver  Important! If you creating fresh docker installation and want to use only one block device as storage - from docker 17.06 you can use autoconfigure feature, simply by adding to /etc/docker/daemon.json following:\n{ \u0026#34;storage-driver\u0026#34;: \u0026#34;devicemapper\u0026#34;, \u0026#34;storage-opts\u0026#34;: [ \u0026#34;dm.directlvm_device=/dev/\u0026lt;your_block_device\u0026#34;, \u0026#34;dm.thinp_percent=95\u0026#34;, \u0026#34;dm.thinp_metapercent=1\u0026#34;, \u0026#34;dm.thinp_autoextend_threshold=80\u0026#34;, \u0026#34;dm.thinp_autoextend_percent=20\u0026#34;, \u0026#34;dm.directlvm_device_force=false\u0026#34; ] } All magic will be done for you.\nDespite that I advice to do manual configuration by yourself.\nWhat parameters mean?  thinp_percent - max space in % allocated for data in Volume Group max space in % allocated for metadata in Volume Group thinp_autoextend_threshold - at what % allocation thinpool will extend itself thinp_autoextend_percent - amount of % than will be allocated at extending event directlvm_device_force - forcing device format   From root - this is direct-lvm method\n Install packages(on CentOS 8+ you probably already have them installed):  [root@docker-host ~]# yum install -y lvm2 device-mapper-persistent-data Failed to set locale, defaulting to C.UTF-8 Last metadata expiration check: 0:21:01 ago on Fri Apr 17 20:23:13 2020. Package lvm2-8:2.03.05-5.el8.0.1.x86_64 is already installed. Package device-mapper-persistent-data-0.8.5-2.el8.x86_64 is already installed. Dependencies resolved. Nothing to do. Complete! On ubuntu it will be thin-provisioning-tools instead of device-mapper-persistent-data.\n Stop docker  [root@docker-host ~]# systemctl stop docker  Check available raw devices - we will use /dev/sdb and /dev/sdc 10GB devices  [root@docker-host ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 32G 0 disk |-sda1 8:1 0 1G 0 part /boot `-sda2 8:2 0 31G 0 part `-cl-root 253:0 0 31G 0 lvm / sdb 8:16 0 10G 0 disk sdc 8:32 0 10G 0 disk sdd 8:48 0 10G 0 disk sr0 11:0 1 6.7G 0 rom  Create LVM physical volumes and volume group, later check that everything is correct by pvs command  [root@docker-host ~]# pvcreate /dev/sdb Physical volume \u0026#34;/dev/sdb\u0026#34; successfully created. [root@docker-host ~]# pvcreate /dev/sdc Physical volume \u0026#34;/dev/sdc\u0026#34; successfully created. [root@docker-host ~]# vgcreate docker /dev/sdb /dev/sdc Volume group \u0026#34;docker\u0026#34; successfully created [root@docker-host ~]# pvs PV VG Fmt Attr PSize PFree /dev/sda2 cl lvm2 a-- \u0026lt;31.00g 0 /dev/sdb docker lvm2 a-- \u0026lt;10.00g \u0026lt;10.00g /dev/sdc docker lvm2 a-- \u0026lt;10.00g \u0026lt;10.00g  Create logical volumes on LVM for thin thinpool(-l defines max percentage of space from VG than LV can use)  [root@docker-host ~]# lvcreate --wipesignatures y -n thinpool docker -l 95%VG Logical volume \u0026#34;thinpool\u0026#34; created. [root@docker-host ~]# lvcreate --wipesignatures y -n thinpoolmeta docker -l 1%VG Logical volume \u0026#34;thinpoolmeta\u0026#34; created  Create thinpool  [root@docker-host ~]# lvconvert -y --zero n -c 512K --thinpool docker/thinpool --poolmetadata docker/thinpoolmeta Thin pool volume with chunk size 512.00 KiB can address at most 126.50 TiB of data. WARNING: Converting docker/thinpool and docker/thinpoolmeta to thin pool\u0026#39;s data and metadata volumes with metadata wiping. THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.) Converted docker/thinpool and docker/thinpoolmeta to thin pool.  Configure profile for thinpool  [root@docker-host ~]# vi /etc/lvm/profile/docker-thinpool.profile activation { thin_pool_autoextend_threshold=80 thin_pool_autoextend_percent=20 }  Apply profile and activate pool monitor  [root@docker-host ~]# lvchange --metadataprofile docker-thinpool docker/thinpool Logical volume docker/thinpool changed. [root@docker-host ~]# lvchange --monitor y docker/thinpool  Configure docker to use devicemapper storage driver  [root@docker-host ~]# vi /etc/docker/daemon.json { \u0026#34;storage-driver\u0026#34;: \u0026#34;devicemapper\u0026#34;, \u0026#34;storage-opts\u0026#34;: [ \u0026#34;dm.thinpooldev=/dev/mapper/docker-thinpool\u0026#34;, \u0026#34;dm.use_deferred_removal=true\u0026#34;, \u0026#34;dm.use_deferred_deletion=true\u0026#34; ] }  Start docker and check that devicemapper is in use  [root@docker-host ~]# systemctl start docker [root@docker-host ~]# docker system info Client: Debug Mode: false Server: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.09.1 Storage Driver: devicemapper Pool Name: docker-thinpool Pool Blocksize: 524.3kB Base Device Size: 10.74GB Backing Filesystem: xfs Udev Sync Supported: true Data Space Used: 19.92MB Data Space Total: 20.39GB Data Space Available: 20.37GB Metadata Space Used: 16.84MB Metadata Space Total: 213.9MB Metadata Space Available: 197.1MB Thin Pool Minimum Free Space: 2.039GB Deferred Removal Enabled: true Deferred Deletion Enabled: true Deferred Deleted Device Count: 0 Library Version: 1.02.163-RHEL8 (2019-06-15) Devicemapper configuration maintenance Add new device to thinpool  Add device to Volume Group  [root@docker-host ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 32G 0 disk |-sda1 8:1 0 1G 0 part /boot `-sda2 8:2 0 31G 0 part `-cl-root 253:0 0 31G 0 lvm / sdb 8:16 0 10G 0 disk `-docker-thinpool_tdata 253:2 0 19G 0 lvm `-docker-thinpool 253:3 0 19G 0 lvm sdc 8:32 0 10G 0 disk |-docker-thinpool_tmeta 253:1 0 204M 0 lvm | `-docker-thinpool 253:3 0 19G 0 lvm `-docker-thinpool_tdata 253:2 0 19G 0 lvm `-docker-thinpool 253:3 0 19G 0 lvm sdd 8:48 0 10G 0 disk sr0 11:0 1 6.7G 0 rom [root@docker-host ~]# pvcreate /dev/sdd Physical volume \u0026#34;/dev/sdd\u0026#34; successfully created. [root@docker-host ~]# vgextend docker /dev/sdd Volume group \u0026#34;docker\u0026#34; successfully extended  Add space to thinpool and check  [root@docker-host ~]# lvextend -l+100%FREE -n docker/thinpool Size of logical volume docker/thinpool_tdata changed from 18.99 GiB (4862 extents) to \u0026lt;29.59 GiB (7575 extents). Logical volume docker/thinpool_tdata successfully resized. [root@docker-host ~]# docker system info Client: Debug Mode: false Server: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.09.1 Storage Driver: devicemapper Pool Name: docker-thinpool Pool Blocksize: 524.3kB Base Device Size: 10.74GB Backing Filesystem: xfs Udev Sync Supported: true Data Space Used: 19.92MB Data Space Total: 31.77GB Data Space Available: 31.75GB Metadata Space Used: 16.84MB Metadata Space Total: 213.9MB Metadata Space Available: 197.1MB Thin Pool Minimum Free Space: 3.177GB Deferred Removal Enabled: true Deferred Deletion Enabled: true Deferred Deleted Device Count: 0 Library Version: 1.02.163-RHEL8 (2019-06-15) Restart LVM after reboot lvchange -ay docker/thinpool\n","href":"/posts/docker_configure_devicemapper/","title":"Docker devicemapper - setup"},{"content":"","href":"/tags/graph-driver/","title":"graph driver"},{"content":"","href":"/tags/lvm/","title":"lvm"},{"content":"","href":"/tags/aufs/","title":"aufs"},{"content":"Each container except read only image space, consume also some writable space from storage layer.\nThis writable and none writable space are managed together by storage driver.\nWhat is storage driver? Storage driver is a plugin for docker which is responsible for creating and maintaining union filesystem used by containers - for example: creating proper directory layout on filesystem.\nIt is important to notice that under storage driver we always have got regular filesystem like ext4, zfs or vfs.\nStorage drivers in docker language are called graph drivers.\nWhat storage driver to choose? For all currently supported Linux distributions preferred storage driver is overlay2. After installing docker it is set by default if kernel supports it.\nIf we want use another driver it is good to follow bellow rules:\n RHEL/CentOS/Fedora - kernel 4.x+ - docker 17.06 and newer - overlay2 RHEL/CentOS/Fedora - kernel lower than 4.x - docker lower than 17.06 - devicemapper Ubuntu/Debian - kernel 4.x+ - overlay2 Ubuntu/Debian - kernel 3.13 - aufs SUSE Linux Enterprise Server - brtfs btrfs or zfs as backing filesystem - btrfs or zfs no copy on write can be used - vfs  Backing Filesystem - /var/lib/docker  overlay2, overlay -\u0026gt; xfs with ftype=1, ext4 aufs\t-\u0026gt; xfs, ext4 devicemapper\t-\u0026gt; direct-lvm btrfs -\u0026gt; btrfs zfs -\u0026gt; zfs vfs -\u0026gt; any filesystem  Checking currently used storage driver [lukas@docker-host ~]$ docker system info Client: Debug Mode: false Server: Containers: 4 Running: 1 Paused: 0 Stopped: 3 Images: 6 Server Version: 18.09.1 Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: true Changing storage driver  Important! Best option is to set storage driver once when we setting up our docker host and not changing it later.\nIf we have to change it on used for a while host, we should remember that:\n main path for docker files for Linux is /var/lib/docker under /var/lib/docker each storage driver creates folder in which storage files are stored - for overlay2 path will be: /var/lib/docker/overlay2, for aufs path will be /var/lib/docker/aufs etc. after changing storage drivers all images and containers writable layers stays at directory for storage driver that created them!  We have to manually move docker images with docker save(before changing driver), docker load(after changing driver) and starting our containers - that all objects get recreated under new storage driver directory.\n From root user or with sudo.\n Stop docker engine  [root@docker-host ~]# systemctl stop docker  Optionally if you want change filesystem in /var/lib/docker format it and remount Set in docker config file storage-driver. In example I will change default overlay2 to older(and not recommended!) overlay.  [root@docker-host ~]# vi /etc/docker/daemon.json { \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay\u0026#34; }  Start docker  [root@docker-host ~]# systemctl start docker  Check that change comes into life  [root@docker-host ~]# docker system info Client: Debug Mode: false Server: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.09.1 Storage Driver: overlay Backing Filesystem: xfs Supports d_type: true As we mentioned in important section, new storage driver directory is empty:\n[root@docker-host ~]# ls -lah /var/lib/docker/overlay2/ total 8.0K drwx------. 33 root root 4.0K Apr 17 13:47 . drwx--x--x. 16 root root 215 Apr 17 15:50 .. drwx------. 4 root root 55 Apr 15 16:46 12b365375674274f8ac0562678fbcece4025cd7e36b2bedb5d738796bd29cc87 drwx------. 4 root root 55 Apr 15 16:46 1d22222ace78d8c5a5dd95b37756b17da5aba98dd2c9ceece2757bb3c3a9bd4a drwx------. 4 root root 55 Apr 17 15:41 1d42f20fa161bede1cf4e14e71e69a8f88e86f3809d3a104ad85c1677ec41187 drwx------. 4 root root 55 Apr 15 16:45 1d42f20fa161bede1cf4e14e71e69a8f88e86f3809d3a104ad85c1677ec41187-init drwx------. 4 root root 55 Apr 15 16:46 26509f1a2e19c59bb9792fa83b6649149360775d28b74f61a2a142cdf291b258 drwx------. 3 root root 30 Apr 14 13:49 46cfa83c2c666559583cb58886f0ee6d6da0d6c70e49464e76857b7dcb264008 drwx------. 4 root root 55 Apr 14 13:49 4c0e521c6b4c7e98798a31fe5d4b5a6247319c97371c0ff10adf78b2adcf15d2 [root@docker-host ~]# ls -lah /var/lib/docker/overlay/ total 0 drwx------. 2 root root 6 Apr 17 15:50 . drwx--x--x. 16 root root 215 Apr 17 15:50 .. We also not seeing our images and containers:\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE Revert back to default overlay2 [root@docker-host ~]# systemctl stop docker [root@docker-host ~]# rm -rf /etc/docker/daemon.json [root@docker-host ~]# systemctl start docker [root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 3 weeks ago 5.6MB localhost:443/alpine latest a187dde48cd2 3 weeks ago 5.6MB localhost:5000/alpine latest a187dde48cd2 3 weeks ago 5.6MB ubuntu 19.10 e9ccb229a23d 3 weeks ago 72.9MB localhost:5000/ubuntu 19.10 e9ccb229a23d 3 weeks ago 72.9MB ","href":"/posts/docker_storage_drivers/","title":"Docker storage driver - setup"},{"content":"","href":"/tags/overlay2/","title":"overlay2"},{"content":"","href":"/tags/docker-registry/","title":"docker registry"},{"content":"Instead of using Docker CLI commands - we can communicate with Docker registry with GET/POST methods of Docker Registry HTTP API.\nPost include information for V2 of API.\nExample setup For our examples we use docker private registry in container. Currently we have got alpine image and couple of ubuntu images loaded in it.\n[lukas@docker-host ~]$ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f628491a985a registry:2 \u0026#34;/entrypoint.sh /etc\u0026#34; About a minute ago Up About a minute 0.0.0.0:5000-\u0026gt;5000/tcp registry If you want to use secure connections - look at curl --help and use parameters associated with CA and certificates like --cacert.\nCheck connection with repository [lukas@docker-host ~]$ curl -X GET http://localhost:5000/v2/ -v Note: Unnecessary use of -X or --request, GET is already inferred. * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 5000 (#0) \u0026gt; GET /v2/ HTTP/1.1 \u0026gt; Host: localhost:5000 \u0026gt; User-Agent: curl/7.61.1 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; Content-Length: 2 \u0026lt; Content-Type: application/json; charset=utf-8 \u0026lt; Docker-Distribution-Api-Version: registry/2.0 \u0026lt; X-Content-Type-Options: nosniff \u0026lt; Date: Wed, 15 Apr 2020 13:34:39 GMT \u0026lt; * Connection #0 to host localhost left intact {}[lukas@docker-host ~]$ List images in registry [lukas@docker-host ~]$ curl -X GET http://localhost:5000/v2/_catalog {\u0026#34;repositories\u0026#34;:[\u0026#34;alpine\u0026#34;,\u0026#34;ubuntu\u0026#34;]} Get available tags for image Check tags for ubuntu image:\n[lukas@docker-host ~]$ curl -X GET http://localhost:5000/v2/ubuntu/tags/list {\u0026#34;name\u0026#34;:\u0026#34;ubuntu\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;latest\u0026#34;,\u0026#34;19.10\u0026#34;,\u0026#34;19.04\u0026#34;,\u0026#34;18.10\u0026#34;]} Check if manifest exists [lukas@docker-host ubuntu-19.10]$ curl -I http://localhost:5000/v2/ubuntu/manifests/19.10 HTTP/1.1 200 OK Content-Length: 5568 Content-Type: application/vnd.docker.distribution.manifest.v1+prettyjws Docker-Content-Digest: sha256:84328f1bc9d8105cb4e5f014cac3eeafda161b58128fb87ea7541f0ec1710669 Docker-Distribution-Api-Version: registry/2.0 Etag: \u0026#34;sha256:84328f1bc9d8105cb4e5f014cac3eeafda161b58128fb87ea7541f0ec1710669\u0026#34; X-Content-Type-Options: nosniff Date: Wed, 15 Apr 2020 14:30:43 GMT Pull image manifest Get metadata for Ubuntu 19.10 image:\n[lukas@docker-host ~]$ curl -X GET http://localhost:5000/v2/ubuntu/manifests/19.10 { \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;ubuntu\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;19.10\u0026#34;, \u0026#34;architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;fsLayers\u0026#34;: [ { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4\u0026#34; }, { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:9460de83957c509dd234ede9ea96d4d03b7f9cd252ef1497844f8450dedb6570\u0026#34; }, { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:22752cd61bd53e9ac71e22fef539c165b3e11b368c1e54ca947260e317c4870a\u0026#34; }, { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:25405ed4f245fc5627d0b03996d04c11d492c7a9ff937f4562a18e8757c39434\u0026#34; }, { \u0026#34;blobSum\u0026#34;: \u0026#34;sha256:eeacba527962683a1b026af611fe162d35281159762b699172caa48c69480f79\u0026#34; } ], \u0026#34;history\u0026#34;: [ { \u0026#34;v1Compatibility\u0026#34;: \u0026#34;{\\\u0026#34;architecture\\\u0026#34;:\\\u0026#34;amd64\\\u0026#34;,\\\u0026#34;config\\\u0026#34;:{\\\u0026#34;Hostname\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;Domainname\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;User\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;AttachStdin\\\u0026#34;:false,\\\u0026#34;AttachStdout\\\u0026#34;:false,\\\u0026#34;AttachStderr\\\u0026#34;:false,\\\u0026#34;Tty\\\u0026#34;:false,\\\u0026#34;OpenStdin\\\u0026#34;:false,\\\u0026#34;StdinOnce\\\u0026#34;:false,\\\u0026#34;Env\\\u0026#34;:[\\\u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\\u0026#34;],\\\u0026#34;Cmd\\\u0026#34;:[\\\u0026#34;/bin/bash\\\u0026#34;],\\\u0026#34;ArgsEscaped\\\u0026#34;:true,\\\u0026#34;Image\\\u0026#34;:\\\u0026#34;sha256:c50c27e497214ed2e11462fe012e6f03516e8c22a96da7c8d43b66ee3d419754\\\u0026#34;,\\\u0026#34;Volumes\\\u0026#34;:null,\\\u0026#34;WorkingDir\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;Entrypoint\\\u0026#34;:null,\\\u0026#34;OnBuild\\\u0026#34;:null,\\\u0026#34;Labels\\\u0026#34;:null},\\\u0026#34;container\\\u0026#34;:\\\u0026#34;245856bcc226438a902b39d236a66777383561c260605f12ca83a4b9bb429a21\\\u0026#34;,\\\u0026#34;container_config\\\u0026#34;:{\\\u0026#34;Hostname\\\u0026#34;:\\\u0026#34;245856bcc226\\\u0026#34;,\\\u0026#34;Domainname\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;User\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;AttachStdin\\\u0026#34;:false,\\\u0026#34;AttachStdout\\\u0026#34;:false,\\\u0026#34;AttachStderr\\\u0026#34;:false,\\\u0026#34;Tty\\\u0026#34;:false,\\\u0026#34;OpenStdin\\\u0026#34;:false,\\\u0026#34;StdinOnce\\\u0026#34;:false,\\\u0026#34;Env\\\u0026#34;:[\\\u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\\u0026#34;],\\\u0026#34;Cmd\\\u0026#34;:[\\\u0026#34;/bin/sh\\\u0026#34;,\\\u0026#34;-c\\\u0026#34;,\\\u0026#34;#(nop) \\\u0026#34;,\\\u0026#34;CMD [\\\\\\\u0026#34;/bin/bash\\\\\\\u0026#34;]\\\u0026#34;],\\\u0026#34;ArgsEscaped\\\u0026#34;:true,\\\u0026#34;Image\\\u0026#34;:\\\u0026#34;sha256:c50c27e497214ed2e11462fe012e6f03516e8c22a96da7c8d43b66ee3d419754\\\u0026#34;,\\\u0026#34;Volumes\\\u0026#34;:null,\\\u0026#34;WorkingDir\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\\\u0026#34;Entrypoint\\\u0026#34;:null,\\\u0026#34;OnBuild\\\u0026#34;:null,\\\u0026#34;Labels\\\u0026#34;:{}},\\\u0026#34;created\\\u0026#34;:\\\u0026#34;2020-03-20T19:20:36.847728128Z\\\u0026#34;,\\\u0026#34;docker_version\\\u0026#34;:\\\u0026#34;18.09.7\\\u0026#34;,\\\u0026#34;id\\\u0026#34;:\\\u0026#34;72c4b1dbff9f650f052e3e8d842d1f9a1c8d5a9a56372450cc655bcfbb51eafc\\\u0026#34;,\\\u0026#34;os\\\u0026#34;:\\\u0026#34;linux\\\u0026#34;,\\\u0026#34;parent\\\u0026#34;:\\\u0026#34;1865fab8daaf362fa003da426809977138cf316781c927ee927b560663ad8899\\\u0026#34;,\\\u0026#34;throwaway\\\u0026#34;:true}\u0026#34; }, { \u0026#34;v1Compatibility\u0026#34;: \u0026#34;{\\\u0026#34;id\\\u0026#34;:\\\u0026#34;1865fab8daaf362fa003da426809977138cf316781c927ee927b560663ad8899\\\u0026#34;,\\\u0026#34;parent\\\u0026#34;:\\\u0026#34;a66a208f5a6d08af66e96314881c2a43adbcc381950cb0dc23b6e6361cac674b\\\u0026#34;,\\\u0026#34;created\\\u0026#34;:\\\u0026#34;2020-03-20T19:20:36.666791568Z\\\u0026#34;,\\\u0026#34;container_config\\\u0026#34;:{\\\u0026#34;Cmd\\\u0026#34;:[\\\u0026#34;/bin/sh -c mkdir -p /run/systemd \\\\u0026\\\\u0026 echo \u0026#39;docker\u0026#39; \\\\u003e /run/systemd/container\\\u0026#34;]}}\u0026#34; }, { \u0026#34;v1Compatibility\u0026#34;: \u0026#34;{\\\u0026#34;id\\\u0026#34;:\\\u0026#34;a66a208f5a6d08af66e96314881c2a43adbcc381950cb0dc23b6e6361cac674b\\\u0026#34;,\\\u0026#34;parent\\\u0026#34;:\\\u0026#34;27fd7159a11d0bb84f765b89ad037900f915d2cdd72bdbc67e8af983b778f7f7\\\u0026#34;,\\\u0026#34;created\\\u0026#34;:\\\u0026#34;2020-03-20T19:20:35.896375229Z\\\u0026#34;,\\\u0026#34;container_config\\\u0026#34;:{\\\u0026#34;Cmd\\\u0026#34;:[\\\u0026#34;/bin/sh -c set -xe \\\\t\\\\t\\\\u0026\\\\u0026 echo \u0026#39;#!/bin/sh\u0026#39; \\\\u003e /usr/sbin/policy-rc.d \\\\t\\\\u0026\\\\u0026 echo \u0026#39;exit 101\u0026#39; \\\\u003e\\\\u003e /usr/sbin/policy-rc.d \\\\t\\\\u0026\\\\u0026 chmod +x /usr/sbin/policy-rc.d \\\\t\\\\t\\\\u0026\\\\u0026 dpkg-divert --local --rename --add /sbin/initctl \\\\t\\\\u0026\\\\u0026 cp -a /usr/sbin/policy-rc.d /sbin/initctl \\\\t\\\\u0026\\\\u0026 sed -i \u0026#39;s/^exit.*/exit 0/\u0026#39; /sbin/initctl \\\\t\\\\t\\\\u0026\\\\u0026 echo \u0026#39;force-unsafe-io\u0026#39; \\\\u003e /etc/dpkg/dpkg.cfg.d/docker-apt-speedup \\\\t\\\\t\\\\u0026\\\\u0026 echo \u0026#39;DPkg::Post-Invoke { \\\\\\\u0026#34;rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true\\\\\\\u0026#34;; };\u0026#39; \\\\u003e /etc/apt/apt.conf.d/docker-clean \\\\t\\\\u0026\\\\u0026 echo \u0026#39;APT::Update::Post-Invoke { \\\\\\\u0026#34;rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true\\\\\\\u0026#34;; };\u0026#39; \\\\u003e\\\\u003e /etc/apt/apt.conf.d/docker-clean \\\\t\\\\u0026\\\\u0026 echo \u0026#39;Dir::Cache::pkgcache \\\\\\\u0026#34;\\\\\\\u0026#34;; Dir::Cache::srcpkgcache \\\\\\\u0026#34;\\\\\\\u0026#34;;\u0026#39; \\\\u003e\\\\u003e /etc/apt/apt.conf.d/docker-clean \\\\t\\\\t\\\\u0026\\\\u0026 echo \u0026#39;Acquire::Languages \\\\\\\u0026#34;none\\\\\\\u0026#34;;\u0026#39; \\\\u003e /etc/apt/apt.conf.d/docker-no-languages \\\\t\\\\t\\\\u0026\\\\u0026 echo \u0026#39;Acquire::GzipIndexes \\\\\\\u0026#34;true\\\\\\\u0026#34;; Acquire::CompressionTypes::Order:: \\\\\\\u0026#34;gz\\\\\\\u0026#34;;\u0026#39; \\\\u003e /etc/apt/apt.conf.d/docker-gzip-indexes \\\\t\\\\t\\\\u0026\\\\u0026 echo \u0026#39;Apt::AutoRemove::SuggestsImportant \\\\\\\u0026#34;false\\\\\\\u0026#34;;\u0026#39; \\\\u003e /etc/apt/apt.conf.d/docker-autoremove-suggests\\\u0026#34;]}}\u0026#34; }, { \u0026#34;v1Compatibility\u0026#34;: \u0026#34;{\\\u0026#34;id\\\u0026#34;:\\\u0026#34;27fd7159a11d0bb84f765b89ad037900f915d2cdd72bdbc67e8af983b778f7f7\\\u0026#34;,\\\u0026#34;parent\\\u0026#34;:\\\u0026#34;b14defeb827d49a068f1d1bb280e312add99650430b71e881f1f6f304d81aefe\\\u0026#34;,\\\u0026#34;created\\\u0026#34;:\\\u0026#34;2020-03-20T19:20:35.087356956Z\\\u0026#34;,\\\u0026#34;container_config\\\u0026#34;:{\\\u0026#34;Cmd\\\u0026#34;:[\\\u0026#34;/bin/sh -c [ -z \\\\\\\u0026#34;$(apt-get indextargets)\\\\\\\u0026#34; ]\\\u0026#34;]}}\u0026#34; }, { \u0026#34;v1Compatibility\u0026#34;: \u0026#34;{\\\u0026#34;id\\\u0026#34;:\\\u0026#34;b14defeb827d49a068f1d1bb280e312add99650430b71e881f1f6f304d81aefe\\\u0026#34;,\\\u0026#34;created\\\u0026#34;:\\\u0026#34;2020-03-20T19:20:34.200290542Z\\\u0026#34;,\\\u0026#34;container_config\\\u0026#34;:{\\\u0026#34;Cmd\\\u0026#34;:[\\\u0026#34;/bin/sh -c #(nop) ADD file:537f9883fb90d19383082b8ac20c17b581db9045a48fa28b83cab73fe317047d in / \\\u0026#34;]}}\u0026#34; } ], \u0026#34;signatures\u0026#34;: [ { \u0026#34;header\u0026#34;: { \u0026#34;jwk\u0026#34;: { \u0026#34;crv\u0026#34;: \u0026#34;P-256\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;EAGI:M5GN:CQT7:AKOB:DROQ:BYVZ:BU3O:3OCP:UPRN:L6QL:FZVJ:DVNX\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;EC\u0026#34;, \u0026#34;x\u0026#34;: \u0026#34;cXGUHd8wxSJc11dZDTWLOJ_rvGX5HLjLwh-rtDyj1KU\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;7gfzvzTXiH2NHhGvdojb2XFLkRvod4gakPyR_6hgJDE\u0026#34; }, \u0026#34;alg\u0026#34;: \u0026#34;ES256\u0026#34; }, \u0026#34;signature\u0026#34;: \u0026#34;DdFJAdzi0t9LrViJrko_ZHwbX_nQwZlLtnkNe1piWVlYrh-8vxtuoNi5NcKvIfwUDK_rosCg705Ob2Gyk26rTQ\u0026#34;, \u0026#34;protected\u0026#34;: \u0026#34;eyJmb3JtYXRMZW5ndGgiOjQ5MjEsImZvcm1hdFRhaWwiOiJDbjAiLCJ0aW1lIjoiMjAyMC0wNC0xNVQxMzo1OTowMFoifQ\u0026#34; } ] } Download image layer via API From manifest file we get list of layers - fsLayers section - with sha256 hashes we can download each layers of image:\n[lukas@docker-host ubuntu-19.10]$ curl -X GET http://localhost:5000/v2/ubuntu/blobs/sha256:eeacba527962683a1b026af611fe162d35281159762b699172caa48c69480f79 --output sha256:eeacba527962683a1b026af611fe162d35281159762b699172caa48c69480f79 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 26.9M 100 26.9M 0 0 350M 0 --:--:-- --:--:-- --:--:-- 350M After downloading all layers:\n[lukas@docker-host ubuntu-19.10]$ ll total 27660 -rw-rw-r--. 1 lukas lukas 844 Apr 15 16:07 sha256:22752cd61bd53e9ac71e22fef539c165b3e11b368c1e54ca947260e317c4870a -rw-rw-r--. 1 lukas lukas 30632 Apr 15 16:07 sha256:25405ed4f245fc5627d0b03996d04c11d492c7a9ff937f4562a18e8757c39434 -rw-rw-r--. 1 lukas lukas 163 Apr 15 16:07 sha256:9460de83957c509dd234ede9ea96d4d03b7f9cd252ef1497844f8450dedb6570 -rw-rw-r--. 1 lukas lukas 32 Apr 15 16:07 sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4 -rw-rw-r--. 1 lukas lukas 28276050 Apr 15 16:08 sha256:eeacba527962683a1b026af611fe162d35281159762b699172caa48c69480f79 Delete image via API By default deleting images is not allowed.\nIf you want allow deleting start registry container with variable -e REGISTRY_STORAGE_DELETE_ENABLED=true\nDelete command only accepts digest hash as reference to image - tags are not supported - we get this digest when we uploading image into repository:\n[lukas@docker-host ~]$ curl -X DELETE http://localhost:5000/v2/ubuntu/manifests/sha256:7ce552ad1c3e94a5c3d2bb24c07000c34a4bb43fd9b379652b2c80593a018e80 We can check that there is no longer Ubuntu 19.10 image in our repository:\n[lukas@docker-host ~]$ curl -X GET http://localhost:5000/v2/ubuntu/tags/list {\u0026#34;name\u0026#34;:\u0026#34;ubuntu\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;latest\u0026#34;,\u0026#34;19.04\u0026#34;,\u0026#34;18.10\u0026#34;]} ","href":"/posts/docker_registry_api_operations/","title":"Docker registry - operations on API"},{"content":"","href":"/tags/docker-login/","title":"docker login"},{"content":"It is very common to setup own Docker registry for our private images.\nBasic registry setup If we want basic setup without TLS and any access control for example for lab, we can create it with command:\n[lukas@docker-host ~]$ docker run -d -p 5000:5000 --restart=always --name registry registry:2 Unable to find image \u0026#39;registry:2\u0026#39; locally 2: Pulling from library/registry 486039affc0a: Pull complete ba51a3b098e6: Pull complete 8bb4c43d6c8e: Pull complete 6f5f453e5f2d: Pull complete 42bc10b72f42: Pull complete Digest: sha256:7d081088e4bfd632a88e3f3bcd9e007ef44a796fddfe3261407a3f9f04abe1e7 Status: Downloaded newer image for registry:2 8f0fec4813cd6dc1d6fc65b8530dd2c3ca413a4e42904debf3005843220bcdb3 [lukas@docker-host ~]$ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8f0fec4813cd registry:2 \u0026#34;/entrypoint.sh /etc\u0026#34; 6 seconds ago Up 5 seconds 0.0.0.0:5000-\u0026gt;5000/tcp registry Docker daemon started registry with 5000 port exposed(we can change it here if we want), named registry using registry:2 image.\nRegistry will be started with Docker host and will be restarted after every failure by --restart=always policy.\nWe can operate on it with standard container commands like docker stop.\nIt is normal container with proper service in it.\nTesting push and pull to private registry Push First tag our local image properly:\n[lukas@docker-host ~]$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 3 weeks ago 5.6MB ubuntu latest 4e5021d210f6 3 weeks ago 64.2MB registry 2 708bc6af7e5e 2 months ago 25.8MB [lukas@docker-host ~]$ docker tag alpine:latest localhost:5000/alpine:latest Push image to private registry:\n[lukas@docker-host ~]$ docker push localhost:5000/alpine:latest The push refers to repository [localhost:5000/alpine] beee9f30bc1f: Pushed latest: digest: sha256:cb8a924afdf0229ef7515d9e5b3024e23b3eb03ddbba287f4a19c6ac90b8d221 size: 528 Pull Remove image from local registry of Docker host:\n[lukas@docker-host ~]$ docker image rm localhost:5000/alpine Untagged: localhost:5000/alpine:latest Untagged: localhost:5000/alpine@sha256:cb8a924afdf0229ef7515d9e5b3024e23b3eb03ddbba287f4a19c6ac90b8d221 Pull image from private registry in container:\n[lukas@docker-host ~]$ docker pull localhost:5000/alpine Using default tag: latest latest: Pulling from alpine Digest: sha256:cb8a924afdf0229ef7515d9e5b3024e23b3eb03ddbba287f4a19c6ac90b8d221 Status: Downloaded newer image for localhost:5000/alpine:latest localhost:5000/alpine:latest [lukas@docker-host ~]$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 3 weeks ago 5.6MB localhost:5000/alpine latest a187dde48cd2 3 weeks ago 5.6MB ubuntu latest 4e5021d210f6 3 weeks ago 64.2MB registry 2 708bc6af7e5e 2 months ago 25.8MB Advanced registry setup Check storage location for registry By default registry container use volumes to store data.\n[lukas@docker-host ~]$ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8f0fec4813cd registry:2 \u0026#34;/entrypoint.sh /etc\u0026#34; 21 minutes ago Up 21 minutes 0.0.0.0:5000-\u0026gt;5000/tcp registry [lukas@docker-host ~]$ docker inspect 8f0fec4813cd [ { \u0026#34;Id\u0026#34;: \u0026#34;8f0fec4813cd6dc1d6fc65b8530dd2c3ca413a4e42904debf3005843220bcdb3\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-04-14T11:49:37.10564264Z\u0026#34;, \u0026#34;Path\u0026#34;: \u0026#34;/entrypoint.sh\u0026#34;, \u0026#34;Args\u0026#34;: [ \u0026#34;/etc/docker/registry/config.yml\u0026#34; ], \u0026#34;State\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;running\u0026#34;, [...] [...] \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;volume\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;6be22c2b38d6d2d4399e16e3d6a8fa5773db550a1d334423743148e8dfb9387e\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/var/lib/docker/volumes/6be22c2b38d6d2d4399e16e3d6a8fa5773db550a1d334423743148e8dfb9387e/_data\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;/var/lib/registry\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Mode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Propagation\u0026#34;: \u0026#34;\u0026#34; [...] From inspect command on registry container we know that /var/lib/registry in it - has got mounted /var/lib/docker/volumes/6be22c2b38d6d2d4399e16e3d6a8fa5773db550a1d334423743148e8dfb9387e/_data from docker host.\nChecking location - there is our apline image pushed earlier:\n[root@docker-host ~]# ls -lah /var/lib/docker/volumes/6be22c2b38d6d2d4399e16e3d6a8fa5773db550a1d334423743148e8dfb9387e/_data/docker/registry/v2/ total 0 drwxr-xr-x. 4 root root 39 Apr 14 13:54 . drwxr-xr-x. 3 root root 16 Apr 14 13:54 .. drwxr-xr-x. 3 root root 20 Apr 14 13:54 blobs drwxr-xr-x. 3 root root 20 Apr 14 13:54 repositories [root@docker-host ~]# ls -lah /var/lib/docker/volumes/6be22c2b38d6d2d4399e16e3d6a8fa5773db550a1d334423743148e8dfb9387e/_data/docker/registry/v2/repositories/ total 0 drwxr-xr-x. 3 root root 20 Apr 14 13:54 . drwxr-xr-x. 4 root root 39 Apr 14 13:54 .. drwxr-xr-x. 5 root root 55 Apr 14 13:54 alpine Set custom storage We can set custom volume location by adding parameter\n-v \u0026lt;docker_host_dir\u0026gt;:/var/lib/registry to docker run command.\nSet TLS to expose registry wider that localhost If you want expose registry with dns name, to wider range of people and servers, configure TLS.\nTo do so:\n get cert and key from CA put into cert location on docker host cert and key:  [lukas@docker-host ~]$ mkdir certs [lukas@docker-host ~]$ mv domain.* certs/  start registry container with additional parameters:   -v \u0026lt;docker_host_cert_dir\u0026gt;:/certs -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/\u0026lt;your_domain_certificate\u0026gt;.crt -e REGISTRY_HTTP_TLS_KEY=/certs/\u0026lt;your_domain_key\u0026gt;.key [lukas@docker-host ~]$ docker run -d --restart=always --name registry -v \u0026#34;$(pwd)\u0026#34;/certs:/certs -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key -p 443:443 registry:2 037409886c9505e5dd47a00fcd13a7684ae586b1133eb8273b0a95cd6a1a70a6 With proper DNS setup you can now use your domain name for pointing private reposiory.\nRegistry restricted access setup If you want to restrict access to registry by setting login and password generate password file for user.\nFor example lukas username and supersecreatpassword123 for password.\nBelow command starts new registry container with modified entrypoint script that will generate hash from given username and password parameters.\n[lukas@docker-host ~]$ docker run --entrypoint htpasswd registry:2 -Bbn lukas supersecretpassword123 \u0026gt; auth/htpasswd [lukas@docker-host ~]$ cat auth/htpasswd lukas:$2y$05$0fIUyTyXPFvJ573I3voFWuienv/Pf2DbclRg/2.ASZFq42hBY1yt6 Now we can start our registry(if you have already started stop it and remove) with additional parameters that activated restricted access\n-v \u0026lt;docker_host_password_file_dir\u0026gt;:/auth -e \u0026quot;REGISTRY_AUTH=htpasswd\u0026quot; -e \u0026quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\u0026quot; -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd [lukas@docker-host ~]$ docker run -d -p 443:443 --restart=always --name registry -v \u0026#34;$(pwd)\u0026#34;/auth:/auth -e \u0026#34;REGISTRY_AUTH=htpasswd\u0026#34; -e \u0026#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\u0026#34; -e REGISTRY_HTTP_ADDR=0.0.0.0:443 -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd -v \u0026#34;$(pwd)\u0026#34;/certs:/certs -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key registry:2 5fcd16c838c5aa2d7ce86c06304dee7890c0e7b1b62a0a36e5fb8811e201dab7 Test login Without login we get failure:\n[lukas@docker-host ~]$ docker push localhost:443/alpine:latest The push refers to repository [localhost:443/alpine] beee9f30bc1f: Preparing no basic auth credentials Now we will login:\n[lukas@docker-host ~]$ docker login localhost:443 Username: lukas Password: WARNING! Your password will be stored unencrypted in /home/lukas/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [lukas@docker-host ~]$ docker push localhost:443/alpine:latest The push refers to repository [localhost:443/alpine] beee9f30bc1f: Pushed latest: digest: sha256:cb8a924afdf0229ef7515d9e5b3024e23b3eb03ddbba287f4a19c6ac90b8d221 size: 528 ","href":"/posts/docker_private_registry_setup/","title":"Docker private registry - setup"},{"content":"From time to time we want export filesystem from container and make image from it.\nAlso sometimes there is need for giving someone our container image in single file without repository usage - on for example pendrive.\nHow to do this things?\nExport and import container filesystem Export To export container filesystem we use command docker export.\nThis command will create output file with whole container filesystem - if we manually uncompress it - we will get directory structure like in / on Linux OS.\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 3 weeks ago 64.2MB In our example we have ubuntu image from which we will start container, there is no testfolder folder in / directory.\nSo ubuntu official image not include such folder.\nLet\u0026rsquo;s add it in our container, with some file in it:\n[lukas@docker-host ~]# docker run -it ubuntu /bin/bash root@86b609d88376:/# pwd / root@86b609d88376:/# ls testfolder ls: cannot access \u0026#39;testfolder\u0026#39;: No such file or directory root@86b609d88376:/# mkdir testfolder root@86b609d88376:/# touch testfolder/file root@86b609d88376:/# ls testfolder/ file root@86b609d88376:/# exit exit Now we can check name of container and perform export from it with docker export and -o parameter for output tar file location.\n[lukas@docker-host ~]# docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 86b609d88376 ubuntu \u0026#34;/bin/bash\u0026#34; 56 seconds ago Exited (0) 8 seconds ago sharp_mclaren [lukas@docker-host ~]# docker export -o ubuntu-export.tar 86b609d88376 [lukas@docker-host ~]# ll total 65024 -rw-------. 1 lukas lukas 66584064 Apr 10 20:59 ubuntu-export.tar Now we have our container filesystem exported into file which we can give to someone!\nImport From tar file we can now create(import) new image by docker import command.\nIt is important to notice that we will create from container export file docker image, not container!\nImport command can take as input network directory also.\n[lukas@docker-host ~]# docker import ubuntu-export.tar ubuntu-testfolder:1.0 sha256:c794b94e40a299a183af988fe6f6485bc065ac0fd95a0e190b2326c805e408f1 [lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu-testfolder 1.0 c794b94e40a2 5 seconds ago 64.2MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 3 weeks ago 64.2MB We can see that our imported image named ubuntu-testfolder:1.0 is on his place.\nLet\u0026rsquo;s make container from it:\n[lukas@docker-host ~]# docker run -it ubuntu-testfolder:1.0 /bin/bash root@8f2842c0158d:/# ls testfolder/ file We have in our image previously created - folder and file.\nDocker export never include files from volumes mounted to container!\nIf you want to add some instructions from Dockerfile before importing image - check in help --change parameter for docker import command.\n Important! docker import command always import image as single layer image, it ignores before export layer layout!\nCompare ubuntu image from which we created container and made export and imported image:\n[lukas@docker-host ~]# docker history ubuntu IMAGE CREATED CREATED BY SIZE COMMENT 4e5021d210f6 3 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c mkdir -p /run/systemd \u0026amp;\u0026amp; echo \u0026#39;do 7B \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c set -xe \u0026amp;\u0026amp; echo \u0026#39;#!/bin/sh\u0026#39; \u0026gt; / 745B \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c [ -z \u0026#34;$(apt-get indextargets)\u0026#34; ] 987kB \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c #(nop) ADD file:594fa35cf803361e6 63.2MB [lukas@docker-host ~]# docker history ubuntu-testfolder:1.0 IMAGE CREATED CREATED BY SIZE COMMENT c794b94e40a2 31 seconds ago 64.2MB Imported from -  Save and load docker image Save and load operates only on images, it has nothing to do with containers.\nSo we save image to file, give it to someone, he or she can load image into his repository.\nSave image docker save will create file with layers and metadata about them instead of filesystem snapshot like in docker export.\nLet\u0026rsquo;s save some image!\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 3 weeks ago 64.2MB [lukas@docker-host ~]# docker save -o ubuntu.tar ubuntu [lukas@docker-host ~]# ll -rw-------. 1 lukas lukas 66612224 Apr 10 21:44 ubuntu.tar Additionally we can check what is inside output tar archive. As we mentioned earlier we should see files structure similar to /var/lib/docker/\u0026lt;storage_driver\u0026gt; location where docker stores images locally.\n[lukas@docker-host ~]# mkdir ubuntu [lukas@docker-host ~]# tar xvf ubuntu.tar -C ubuntu 4bea34c6cbddb48774fb9dea97758ae7148d309bb4f2b51ceda03904a8124b8b/ 4bea34c6cbddb48774fb9dea97758ae7148d309bb4f2b51ceda03904a8124b8b/VERSION 4bea34c6cbddb48774fb9dea97758ae7148d309bb4f2b51ceda03904a8124b8b/json 4bea34c6cbddb48774fb9dea97758ae7148d309bb4f2b51ceda03904a8124b8b/layer.tar 4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd.json a514b8e33bd194200e62e981fa0e9bb3c13c6cd04ff82e91f3e8f11bd4f3500c/ a514b8e33bd194200e62e981fa0e9bb3c13c6cd04ff82e91f3e8f11bd4f3500c/VERSION a514b8e33bd194200e62e981fa0e9bb3c13c6cd04ff82e91f3e8f11bd4f3500c/json a514b8e33bd194200e62e981fa0e9bb3c13c6cd04ff82e91f3e8f11bd4f3500c/layer.tar ca00c330587678e46fabf95ff50e16d9cc64bc0de5fc684694ac5266c39f69e6/ ca00c330587678e46fabf95ff50e16d9cc64bc0de5fc684694ac5266c39f69e6/VERSION ca00c330587678e46fabf95ff50e16d9cc64bc0de5fc684694ac5266c39f69e6/json ca00c330587678e46fabf95ff50e16d9cc64bc0de5fc684694ac5266c39f69e6/layer.tar d3bc4608f672143c84e7f1e0db9a00e5067213562f22fcd5b601a920d23859a2/ d3bc4608f672143c84e7f1e0db9a00e5067213562f22fcd5b601a920d23859a2/VERSION d3bc4608f672143c84e7f1e0db9a00e5067213562f22fcd5b601a920d23859a2/json d3bc4608f672143c84e7f1e0db9a00e5067213562f22fcd5b601a920d23859a2/layer.tar manifest.json repositories In random matedata json file, we will see all metadata about layer:\n[lukas@docker-host ~]# vi ubuntu/d3bc4608f672143c84e7f1e0db9a00e5067213562f22fcd5b601a920d23859a2/json {\u0026#34;id\u0026#34;:\u0026#34;d3bc4608f672143c84e7f1e0db9a00e5067213562f22fcd5b601a920d23859a2\u0026#34;,\u0026#34;parent\u0026#34;:\u0026#34;a514b8e33bd194200e62e981fa0e9bb3c13c6cd04ff82e91f3e8f11bd4f3500c\u0026#34;,\u0026#34;created\u0026#34;:\u0026#34;1970-01-01T01:00:00+01:00\u0026#34;,\u0026#34;container_config\u0026#34;:{\u0026#34;Hostname\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Domainname\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;User\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;AttachStdin\u0026#34;:false,\u0026#34;AttachStdout\u0026#34;:false,\u0026#34;AttachStderr\u0026#34;:false,\u0026#34;Tty\u0026#34;:false,\u0026#34;OpenStdin\u0026#34;:false,\u0026#34;StdinOnce\u0026#34;:false,\u0026#34;Env\u0026#34;:null,\u0026#34;Cmd\u0026#34;:null,\u0026#34;Image\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Volumes\u0026#34;:null,\u0026#34;WorkingDir\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Entrypoint\u0026#34;:null,\u0026#34;OnBuild\u0026#34;:null,\u0026#34;Labels\u0026#34;:null},\u0026#34;os\u0026#34;:\u0026#34;linux\u0026#34;} Load image First, we remove ubuntu image from out local repository:\n[lukas@docker-host ~]# docker image rm ubuntu Untagged: ubuntu:latest Untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d Deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd Deleted: sha256:1d9112746e9d86157c23e426ce87cc2d7bced0ba2ec8ddbdfbcc3093e0769472 Deleted: sha256:efcf4a93c18b5d01aa8e10a2e3b7e2b2eef0378336456d8653e2d123d6232c1e Deleted: sha256:1e1aa31289fdca521c403edd6b37317bf0a349a941c7f19b6d9d311f59347502 Deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853 [lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB Next we will perform load with docker load command:\n[lukas@docker-host ~]# docker load -i ubuntu.tar c8be1b8f4d60: Loading layer [==================================================\u0026gt;] 65.58MB/65.58MB 977183d4e999: Loading layer [==================================================\u0026gt;] 991.2kB/991.2kB 6597da2e2e52: Loading layer [==================================================\u0026gt;] 15.87kB/15.87kB 16542a8fc3be: Loading layer [==================================================\u0026gt;] 3.072kB/3.072kB Loaded image: ubuntu:latest [lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 3 weeks ago 64.2MB Other than import operation, loading adds all metadata and all layers of image as they were before load operation:\n[lukas@docker-host ~]# docker history ubuntu IMAGE CREATED CREATED BY SIZE COMMENT 4e5021d210f6 3 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c mkdir -p /run/systemd \u0026amp;\u0026amp; echo \u0026#39;do 7B \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c set -xe \u0026amp;\u0026amp; echo \u0026#39;#!/bin/sh\u0026#39; \u0026gt; / 745B \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c [ -z \u0026#34;$(apt-get indextargets)\u0026#34; ] 987kB \u0026lt;missing\u0026gt; 3 weeks ago /bin/sh -c #(nop) ADD file:594fa35cf803361e6 63.2MB ","href":"/posts/docker_save_load_export_import/","title":"Docker container and image - export and save"},{"content":"","href":"/tags/docker-export/","title":"docker export"},{"content":"","href":"/tags/docker-import/","title":"docker import"},{"content":"","href":"/tags/docker-load/","title":"docker load"},{"content":"","href":"/tags/docker-save/","title":"docker save"},{"content":"","href":"/tags/docker-image/","title":"docker image"},{"content":"Docker has got couple commands that allows us to manage images.\nList images Usage of docker image ls is described in another post: Docker image - list\nRemove images Let\u0026rsquo;s check what images we have locally:\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 8 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB We have ubuntu image that has got two aliases: ubuntu:latest and ubuntu:18.04\nLet\u0026rsquo;s remove one of it:\n[lukas@docker-host ~]# docker image rm ubuntu:18.04 Untagged: ubuntu:18.04 [lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 8 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB As we saw docker image rm removed only alias - if we remove last image alias - image will be deleted also - precisely layers that are no longer needed:\n[lukas@docker-host ~]# docker image rm ubuntu:latest Untagged: ubuntu:latest Untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d Deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd Deleted: sha256:1d9112746e9d86157c23e426ce87cc2d7bced0ba2ec8ddbdfbcc3093e0769472 Deleted: sha256:efcf4a93c18b5d01aa8e10a2e3b7e2b2eef0378336456d8653e2d123d6232c1e Deleted: sha256:1e1aa31289fdca521c403edd6b37317bf0a349a941c7f19b6d9d311f59347502 Deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853 Normally docker doesn\u0026rsquo;t allow us to delete image from which containers are currently running. We can use --force in remove command, it will remove also containers running from images we are trying to delete.\nRemove dandling and unused images We can remove dandling(without repository and tag) images with docker image prune. In our example all images has got repository and tag so none of them will be removed.\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 8 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB [lukas@docker-host ~]# docker image prune WARNING! This will remove all dangling images. Are you sure you want to continue? [y/N] y Total reclaimed space: 0B We can use -a parameter to remove all images not associated with containers.\nI dont\u0026rsquo; have any containers in example so all images should be deleted by this command.\n[lukas@docker-host ~]# docker image prune -a WARNING! This will remove all images without at least one container associated to them. Are you sure you want to continue? [y/N] y Deleted Images: untagged: schickling/postgres-backup-s3:latest untagged: schickling/postgres-backup-s3@sha256:77fb08dff3a07d850ba88fd072e9f2938f8dd5e267411238fd9814ccec14a34f deleted: sha256:e8e41fa54edbb0e98f4ef20edfdca3f83732b084d4a7524ea87544ff030b4605 [...] deleted: sha256:cd7100a72410606589a54b932cabd804a17f9ae5b42a1882bd56d263e02b6215 untagged: ubuntu:18.04 untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd [...] deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853 untagged: postgres:latest untagged: postgres@sha256:d480b197ab8e01edced54cbbbba9707373473f42006468b60be04da07ce97823 deleted: sha256:9907cacf0c01916f9cd5fef24ae0daf564098afe0f7904962b9cb99758823461 deleted: sha256:736efdcf1e7318755b2ea260d89a859e8d7f8614f9746fcb092e8cbc66a0849f [...] deleted: sha256:c3a984abe8a88059915bb6c7a1d249fd1ccc16d931334ac8816540b0eb686b45 untagged: alpine:latest untagged: alpine@sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239 deleted: sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72 deleted: sha256:beee9f30bc1f711043e78d4a2be0668955d4b761d587d6f60c2c8dc081efb203 untagged: ubuntu:19.04 untagged: ubuntu@sha256:2adeae829bf27a3399a0e7db8ae38d5adb89bcaf1bbef378240bc0e6724e8344 deleted: sha256:c88ac1f841b72add46f5a8b0e77c2ad6864d47e5603686ea64375acd55e27906 [...] deleted: sha256:873cbe4bd21ee6f6ea264cfc50c0b35b0c3a00e2be3f82b30884c3b9da5db2db Total reclaimed space: 570.3MB Like in docker image ls --filter parameters works here, more about it in: Docker image - list\nCheck image build steps [lukas@docker-host ~]# docker image history 4e5021d210f6 IMAGE CREATED CREATED BY SIZE COMMENT 4e5021d210f6 2 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c mkdir -p /run/systemd \u0026amp;\u0026amp; echo \u0026#39;do 7B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c set -xe \u0026amp;\u0026amp; echo \u0026#39;#!/bin/sh\u0026#39; \u0026gt; / 745B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c [ -z \u0026#34;$(apt-get indextargets)\u0026#34; ] 987kB \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) ADD file:594fa35cf803361e6 63.2MB We see that intermediate layers have got \u0026lt;missing\u0026gt; image id - this id\u0026rsquo;s was removed because of moving image within different hosts. There are no longer by build cache.\nBy default commands are truncated but it is possibility to extend them to full size by adding --no-trunc parameter.\nInspect images To view metadata about image we can use docker image inspect command:\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [lukas@docker-host ~]# docker image inspect a187dde48cd2 [ { \u0026#34;Id\u0026#34;: \u0026#34;sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72\u0026#34;, \u0026#34;RepoTags\u0026#34;: [ \u0026#34;alpine:latest\u0026#34; ], \u0026#34;RepoDigests\u0026#34;: [ \u0026#34;alpine@sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239\u0026#34; ], \u0026#34;Parent\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Comment\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-03-23T21:19:34.196162891Z\u0026#34;, \u0026#34;Container\u0026#34;: \u0026#34;fb71ddde5f6411a82eb056a9190f0cc1c80d7f77a8509ee90a2054428edb0024\u0026#34;, \u0026#34;ContainerConfig\u0026#34;: { \u0026#34;Hostname\u0026#34;: \u0026#34;fb71ddde5f64\u0026#34;, \u0026#34;Domainname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;User\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AttachStdin\u0026#34;: false, \u0026#34;AttachStdout\u0026#34;: false, \u0026#34;AttachStderr\u0026#34;: false, \u0026#34;Tty\u0026#34;: false, \u0026#34;OpenStdin\u0026#34;: false, \u0026#34;StdinOnce\u0026#34;: false, \u0026#34;Env\u0026#34;: [ \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; ], \u0026#34;Cmd\u0026#34;: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;#(nop) \u0026#34;, \u0026#34;CMD [\\\u0026#34;/bin/sh\\\u0026#34;]\u0026#34; ], \u0026#34;ArgsEscaped\u0026#34;: true, \u0026#34;Image\u0026#34;: \u0026#34;sha256:74df73bb19fbfc7fb5ab9a8234b3d98ee2fb92df5b824496679802685205ab8c\u0026#34;, \u0026#34;Volumes\u0026#34;: null, \u0026#34;WorkingDir\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Entrypoint\u0026#34;: null, \u0026#34;OnBuild\u0026#34;: null, \u0026#34;Labels\u0026#34;: {} }, \u0026#34;DockerVersion\u0026#34;: \u0026#34;18.09.7\u0026#34;, \u0026#34;Author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Config\u0026#34;: { \u0026#34;Hostname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Domainname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;User\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AttachStdin\u0026#34;: false, \u0026#34;AttachStdout\u0026#34;: false, \u0026#34;AttachStderr\u0026#34;: false, \u0026#34;Tty\u0026#34;: false, \u0026#34;OpenStdin\u0026#34;: false, \u0026#34;StdinOnce\u0026#34;: false, \u0026#34;Env\u0026#34;: [ \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; ], \u0026#34;Cmd\u0026#34;: [ \u0026#34;/bin/sh\u0026#34; ], \u0026#34;ArgsEscaped\u0026#34;: true, \u0026#34;Image\u0026#34;: \u0026#34;sha256:74df73bb19fbfc7fb5ab9a8234b3d98ee2fb92df5b824496679802685205ab8c\u0026#34;, \u0026#34;Volumes\u0026#34;: null, \u0026#34;WorkingDir\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Entrypoint\u0026#34;: null, \u0026#34;OnBuild\u0026#34;: null, \u0026#34;Labels\u0026#34;: null }, \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Os\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;Size\u0026#34;: 5595566, \u0026#34;VirtualSize\u0026#34;: 5595566, \u0026#34;GraphDriver\u0026#34;: { \u0026#34;Data\u0026#34;: { \u0026#34;MergedDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/d005a98ba83c1d08b18a3d1b22470146b1ccd6541e6132691d746441b3f378f2/merged\u0026#34;, \u0026#34;UpperDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/d005a98ba83c1d08b18a3d1b22470146b1ccd6541e6132691d746441b3f378f2/diff\u0026#34;, \u0026#34;WorkDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/d005a98ba83c1d08b18a3d1b22470146b1ccd6541e6132691d746441b3f378f2/work\u0026#34; }, \u0026#34;Name\u0026#34;: \u0026#34;overlay2\u0026#34; }, \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:beee9f30bc1f711043e78d4a2be0668955d4b761d587d6f60c2c8dc081efb203\u0026#34; ] }, \u0026#34;Metadata\u0026#34;: { \u0026#34;LastTagTime\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; } } ] Tag images We can change image name(repository and tag) by docker image tag command:\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [lukas@docker-host ~]# docker image tag alpine:latest alpine-lukas:1.0 [lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine-lukas 1.0 a187dde48cd2 2 weeks ago 5.6MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB In previous example we create another image(it is alias because of smart storage management in Docker).\nIf we want prepare image for sending remotely we can add repository name, later we can push this image to remote registry:\n[lukas@docker-host ~]# docker image tag alpine-lukas:1.0 registry.lukas.it/alpine-lukas:1.0 [lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine-lukas 1.0 a187dde48cd2 2 weeks ago 5.6MB alpine latest a187dde48cd2 2 weeks ago 5.6MB registry.lukas.it/alpine-lukas 1.0 a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ","href":"/posts/docker_image_commands/","title":"Docker image - commands"},{"content":"Docker has got couple commands that allows us to manage images. Mostly we are getting list of images.\nBasic listing Basic images listing with command: docker image ls.\nSize is cumulative value from all layers needed for image.\nBelow images are local images without repository specified.\n[lukas@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Searching for specific image in local repo on host.\nWorks also with tag eg.: docker image ls ubuntu:18.04\n[lukas@docker-host ~]# docker image ls ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB Without truncating output: [lukas@docker-host ~]# docker image ls --no-trunc postgres latest sha256:9907cacf0c01916f9cd5fef24ae0daf564098afe0f7904962b9cb99758823461 6 days ago 314MB alpine latest sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72 2 weeks ago 5.6MB ubuntu 18.04 sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd 2 weeks ago 64.2MB ubuntu latest sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd 2 weeks ago 64.2MB ubuntu 19.04 sha256:c88ac1f841b72add46f5a8b0e77c2ad6864d47e5603686ea64375acd55e27906 2 months ago 70MB Quiet mode Useful if we need only image ID for script or another command:\n[lukas@docker-host ~]# docker image ls -q 9907cacf0c01 a187dde48cd2 4e5021d210f6 4e5021d210f6 c88ac1f841b7 Listing with digest hash Digest is sha256 hash. If two images has got same digest hash, they have got the same content.\nBelow we have three images of ubuntu. From digest we get information that latest image and 18.04 are the same.\nSo if you pull ubuntu:latest, you get ubuntu:18.04\n[lukas@docker-host ~]# docker image ls --digests REPOSITORY TAG DIGEST IMAGE ID CREATED SIZE postgres latest sha256:d480b197ab8e01edced54cbbbba9707373473f42006468b60be04da07ce97823 9907cacf0c01 6 days ago 314MB alpine latest sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239 a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 sha256:2adeae829bf27a3399a0e7db8ae38d5adb89bcaf1bbef378240bc0e6724e8344 c88ac1f841b7 2 months ago 70MB Filtering images Get images without tags Images without tags are called dandling.\nThis type of images is created when we build or tag image with [REPOSITORY[:TAG]] name of existing image.\nNew image gets [REPOSITORY[:TAG]], old one gets name: [NONE[:NONE]]\n[lukas@docker-host ~]# docker images --filter \u0026#34;dangling=true\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE [lukas@docker-host ~]# docker images --filter \u0026#34;dangling=false\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Get images by labels In example, we search for every image with maintaner label set(I pulled this image additionally because none of official ubuntu and postgres images has got label added):\n[lukas@docker-host ~]# docker image ls --filter \u0026#34;label=maintainer\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB Get images created before another image We can insted of before use since for images created after given image.\n[lukas@docker-host ~]# docker image ls --filter \u0026#34;before=ubuntu:19.04\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB [lukas@docker-host ~]# docker image ls --filter \u0026#34;before=postgres:latest\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB Wildcard search [lukas@docker-host ~]# docker image ls --filter=reference=\u0026#39;*:latest\u0026#39; REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [lukas@docker-host ~]# docker image ls --filter=reference=\u0026#39;ubuntu:*.04\u0026#39; REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Pretty output format [lukas@docker-host ~]# docker image ls --format \u0026#34;{{.ID}}\u0026#34; 9907cacf0c01 a187dde48cd2 4e5021d210f6 4e5021d210f6 c88ac1f841b7 e8e41fa54edb [lukas@docker-host ~]# docker image ls --format \u0026#34;{{.ID}}:{{.Tag}}\u0026#34; 9907cacf0c01:latest a187dde48cd2:latest 4e5021d210f6:18.04 4e5021d210f6:latest c88ac1f841b7:19.04 e8e41fa54edb:latest [lukas@docker-host ~]# docker image ls --format \u0026#34;Image {{.ID}} has got tag {{.Tag}}\u0026#34; Image 9907cacf0c01 has got tag latest Image a187dde48cd2 has got tag latest Image 4e5021d210f6 has got tag 18.04 Image 4e5021d210f6 has got tag latest Image c88ac1f841b7 has got tag 19.04 Image e8e41fa54edb has got tag latest Options list  .ID\t- Image ID .Repository\t- Image repository .Tag- Image tag .Digest -\tImage digest .CreatedSince -\tElapsed time since the image was created .CreatedAt - Time when the image was created .Size -\tImage disk size  ","href":"/posts/docker_image_listing/","title":"Docker image - list"},{"content":"","href":"/tags/kubeconfig/","title":"KUBECONFIG"},{"content":"","href":"/tags/kubectl/","title":"kubectl"},{"content":"Kubectl client gives us possibility to configure and switch easy between multiple K8s clusters.\nConfig files location for kubectl Main location for kubectl config files is $HOME/.kube, by default we have single config file named config:\n[node1 ~]$ cd $HOME/.kube [node1 .kube]$ ls -lah total 4.0K drwxr-xr-x 1 root root 37 Mar 12 20:48 . dr-xr-x--- 1 root root 19 Nov 29 11:46 .. drwxr-x--- 3 root root 23 Mar 12 20:48 cache lrwxrwxrwx 1 root root 26 Nov 29 11:46 config -\u0026gt; /etc/kubernetes/admin.conf drwxr-x--- 3 root root 4.0K Mar 12 20:48 http-cache Multiple config files and KUBECONFIG variable We can have multiple config files by setting proper KUBECONFIG shell variable.\nFor example:\nexport KUBECONFIG=$KUBECONFIG:/root/.kube/additional_config\nCheck config from kubectl We can check current config(it will be empty because I don\u0026rsquo;t have anything in additional_config file - we\u0026rsquo;ll add something later - and this is only file in my KUBECONFIG variable):\n[node1 ~]$ kubectl config view apiVersion: v1 clusters: [] contexts: [] current-context: \u0026#34;\u0026#34; kind: Config preferences: {} users: [] Or from specific file - let\u0026rsquo;s see default file:\n[node1 ~]$ kubectl config --kubeconfig=.kube/config view apiVersion: v1 clusters: - cluster: certificate-authority-data: DATA+OMITTED server: https://192.168.0.38:6443 name: kubernetes contexts: - context: cluster: kubernetes user: kubernetes-admin name: kubernetes-admin@kubernetes current-context: kubernetes-admin@kubernetes kind: Config preferences: {} users: - name: kubernetes-admin user: client-certificate-data: REDACTED client-key-data: REDACTED If you don\u0026rsquo;t set KUBECONFIG variable all configuration will be taken from $HOME/.kube/config\nObjects in kubectl config kubectl has in his config files following object types:\n clusters - info about K8s cluster - contain cluster name and connection parameters users - info about users by which you want connect to K8s clusters contexts - triple of cluster/user/namespace  Modifying config from kubectl Add cluster [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-cluster dev --server=https://192.168.1.100 --certificate-authority=fake-ca Cluster \u0026#34;dev\u0026#34; set. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-cluster prod --server=https://10.1.1.100 --certificate-authority=fake-ca Cluster \u0026#34;prod\u0026#34; set. Add users [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-credentials developer --client-certificate=fake-cert-file --client-key=fake-key-seefile User \u0026#34;developer\u0026#34; set. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-credentials prod_admin --client-certificate=fake-cert-file --client-key=fake-key-seefile User \u0026#34;prod_admin\u0026#34; set. Add contexts [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-context simple_app_development --cluster=dev --namespace=simple_app_dev --user=developer Context \u0026#34;simple_app_development\u0026#34; created. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-context simple_app_production --cluster=prod --namespace=simple_app_prod --user=prod_admin Context \u0026#34;simple_app_production\u0026#34; created. Delete cluster/user/context from config kubectl --kubeconfig=.kube/additional_config config unset users.\u0026lt;name\u0026gt; kubectl --kubeconfig=.kube/additional_config config unset clusters.\u0026lt;name\u0026gt; kubectl --kubeconfig=.kube/additional_config config unset contexts.\u0026lt;name\u0026gt; Sample config [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config view apiVersion: v1 clusters: - cluster: certificate-authority: /root/fake-ca server: https://192.168.1.100 name: dev - cluster: certificate-authority: /root/fake-ca server: https://10.1.1.100 name: prod contexts: - context: cluster: dev namespace: simple_app_dev user: developer name: simple_app_development - context: cluster: prod namespace: simple_app_prod user: prod_admin name: simple_app_production current-context: \u0026#34;\u0026#34; kind: Config preferences: {} users: - name: developer user: client-certificate: /root/fake-cert-file client-key: /root/fake-key-seefile - name: prod_admin user: client-certificate: /root/fake-cert-file client-key: /root/fake-key-seefile Changing context we working with To get list of contexts(no need for --kubeconfig because we have our additional_config added to KUBECONFIG variable):\n[node1 ~]$ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE simple_app_development dev developer simple_app_dev simple_app_production prod prod_admin simple_app_prod To set context:\n[node1 ~]$ kubectl config use-context simple_app_development Switched to context \u0026#34;simple_app_development\u0026#34;. To get current context:\n[node1 ~]$ kubectl config current-context simple_app_development ","href":"/posts/kubernetes_kubectl_client_config/","title":"Kubectl - configuration"},{"content":"","href":"/categories/kubernetes/","title":"kubernetes"},{"content":"","href":"/tags/docker-build/","title":"docker build"},{"content":"All docker containers are started from an image.\nWhat\u0026rsquo;s an image? Image is a collection of read only layers with everything we need to run application. Commonly in image we have base layout of operating system we had choose and some necessary binaries to start our application.\nFor exaple, for PostgreSQL container image could contain CentOS base filesystem template, PostgreSQL binaries and some configuration files.\nHow we build image? We build image by issuing command docker build, but before we use it we need to create a Docker file.\nSimplest-minimal command to build image:\ndocker build -t postgresql-server:11.6 .\nWe just use -t for setting image name and tag.\nDot at the end means that for build context we choose current dir - we could specify here full path to build context directory, which should provide Dockerfile and other files that we want to copy into our image at building process.\nAnother important docker build parameters are:\n --pull - Always pull a newer version of the image from which we build --no-cache - disable layer build cache --build-arg - send to docker daemon values for parameters from Dockerfile --file - choose custom Dockerfile location(out of build context directory)  For complete list check docker build -h\nBefore we use below command first we have to prepair Dockerfile.\nWhat is a Dockerfile? Dockerfile is text file with all commands needed to create environment for our application. We can easly define what files we want to include in our image, what binaries will run in container or what ports we want to expose from it. Using Dockerfile gives us possibility to fast create multiple enviroments just by modifying file and reissuing docker build.\nAssume that we have our java application in 0.1 version currently running - we get from dev team 0.2. Only thing we have to do is to change in Dockerfile path to jar file(or if we put app version in variable use parameter --build-arg - later about it in sample) and issue docker build - of course we should provide proper name for new image which will reflect app version. After image build we can start container with new application.\nSample Dockerfile FROMcentos:7LABEL maintainer=\u0026#34;lukas@mail.com\u0026#34;ARG PG_MAJORARG PG_MINORENV PG_MAJOR=${PG_MAJOR:-11}ENV PG_MINOR=${PG_MINOR:-5}ENV PG_PORT 5432ENV PG_USER_ID 2201ENV PG_USER_GID 2201ENV PG_ENCODING UTF8ENV PG_LOCALE en_US.UTF8ENV PG_AUTH md5ENV PG_AUTH_HOST md5ENV PG_AUTH_LOCAL md5RUN groupadd -g ${PG_USER_GID} postgres; useradd -g ${PG_USER_GID} -u ${PG_USER_ID} postgresCOPY my-yum-repo.repo /etc/yum.repos.d/RUN yum update -y; \\  yum -y install \\  postgresql11-server-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-contrib-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-libs-${PG_MAJOR}.${PG_MINOR}; \\  yum clean all;ENV PATH $PATH:/usr/pgsql-${PG_MAJOR}/binENV PG_DIR /postgresqlENV PG_DATA ${PG_DIR}/data/pg${PG_MAJOR}ENV WAL_DATA ${PG_DIR}/walRUN set -ex; \\  mkdir -p ${PG_DIR}; \\  mkdir -p ${PG_DATA}; \\  mkdir -p ${WAL_DATA}; \\  chown -R postgres:postgres ${PG_DIR}; \\  chmod 750 -R ${PG_DIR};VOLUME${PG_DIR}VOLUME${WAL_DATA}COPY docker-entrypoint.sh /usr/local/binRUN chmod u+x /usr/local/bin/docker-entrypoint.shENTRYPOINT [\u0026#34;/usr/local/bin/docker-entrypoint.sh\u0026#34;]EXPOSE5432What commands in Dockerfile we have? FROM FROM [--platform=\u0026lt;platform\u0026gt;] \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;]\nFROM centos7\nFROM tells Docker Engine which image it has to use as base image for current build.\n[--platform=\u0026lt;platform\u0026gt;] flag can be used to specify the platform of the image when we are building multi-platform image. For example, linux/amd64. By default image is build with platform on which build is triggered.\n[AS \u0026lt;name\u0026gt;] clause is used for creating multi stage builds. I will cover this topic in another post.\nIn example we use CentOS operating system, we didn\u0026rsquo;t specified any tag because we want newest CentOS image for version 7.\nEvery command under FROM directive will be run on base image. It\u0026rsquo;s important to notice that we don\u0026rsquo;t have to use as base images OS image. We can use any correctly build image, and build on top of it.\nIt is possible to parametrize image version specified in FROM clause with ARG and --build-arg.\nARG ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;]\nARG PG_MAJOR\nARG PG_MINOR\nARG clause define build time variable.\nWe can pass parameters for it with --build-arg for docker build also we can specify default value for it in case of omitting in --build-arg by doing like ARG PG_MINOR=11.\nThis variables are available only at build time!\nIn our example we user ARG for PostgreSQL version. By doing so, we can build from one Dockerfile multiple images with different PostgreSQL engines. We can use ARG before FROM for parametrizing version of base image.\nENV ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\nENV PG_PORT 5432\nENV clause define runtime variable.\nIn form without = sign - all characters after name of variable are treat as one string including whitespaces. The ENV variables will persist when a container is run. We can change them using docker run --env \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; on next container start.\nARG/ENV trick ARG PG_MAJOR\nARG PG_MINOR\nENV PG_MAJOR=${PG_MAJOR:-11}\nENV PG_MINOR=${PG_MINOR:-5}\nWhy we do something like this?\nAs mentioned, ENV - runtime variable, ARG build variable which can\u0026rsquo;t be accessed at container runtime.\nIn our example, we want to modify version of PostgreSQL which we will use at build time, but what if after build we need this variable values for some operations which can happen in some scripts in our container?\nTo persist this variables and make them available in running container we make ARG variables without default. Later we use them to set ENV's. Also we move default values set to ENV(shell syntax for setting default value).\nNow we can manipulate values with docker build --build-arg, but we also have them available after build at running container.\nLABEL LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\nLABEL maintainer=\u0026quot;lukas@mail.com\u0026quot;\nLABEL is used for adding some metadata to image which we will be visible in docker inspect output.\nIn example we add info about image building person.\nWe can specify multiple labels - in multiple or one line.\nRUN RUN \u0026lt;command\u0026gt;\nRUN [\u0026quot;exec\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\nRUN chmod u+x /usr/local/bin/docker-entrypoint.sh\nRUN execute command on operating system of container.\nIf you just give command after RUN it will be execute in shell - for Linux it will be probably bash. If you use [](JSON form) it will execute command in raw mode - without shell characteristic behaviours. You should remember to use \u0026quot;\u0026rdquo; around each part of command.\nEach RUN command creates new layer in image. Lesser layers, the better. Always try to merge multiple commands making some logical unit of work into one RUN statement.\nFor example, appending to file, moving it and changing permissions.\nUse for it shell syntax like RUN \u0026lt;command\u0026gt;; \u0026lt;command2\u0026gt;; \u0026lt;command3\u0026gt; in Linux.\nCOPY \u0026amp; ADD ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\nCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\nCOPY my-yum-repo.repo /etc/yum.repos.d/\nADD and COPY command will move files or directories from src to dest. In most cases COPY is command you need. ADD will be used only when you want to copy from URL - that is main difference between them, COPY don\u0026rsquo;t work over network - just local files.\nIn both cases build context is your \u0026ldquo;root\u0026rdquo; path from which you can use relative paths like somefolder/somefolder2/somefile\nIn both cases you can use wildcards like * or ?.\nIn both cases you can use [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] parameter to set owner and group for things that you place into image.\nVOLUME VOLUME [\u0026quot;\u0026lt;path\u0026gt;\u0026quot;]\nVOLUME ${PG_DIR}\nVOLUME creates mount point in filesystem of container for external volumes.\nENTRYPOINT \u0026amp; COMMAND ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\nENTRYPOINT [\u0026quot;/usr/local/bin/docker-entrypoint.sh\u0026quot;]\nENTRYPOINT defines binary or shell script which will start immediately after starting container.\nIn our example we have docker-entrypoint.sh script which can contain logic like: if $PG_DATA empty initialize new postgresql cluster with initdb, if not empty - start postgresql with /usr/bin/postgres -D $PG_DATA.\nWe can pass arguments to ENTRYPOINT by adding it to docker run after image name.\nCOMMAND clause will be support command for ENTRYPOINT - it will hold default parameters for binary started in ENTRYPOINT in case when they are must exists and we do not pass anything to docker run. In our example there isn\u0026rsquo;t need for using COMMAND.\nIt is possible to override ENTRYPOINT when starting container with docker run --entrypoint parameter.\nEXPOSE EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;/\u0026lt;protocol\u0026gt;]\nEXPOSE 5432\nEXPOSE is documentation command that shows at which ports services in container will listen.\nUSER USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;]\nUSER instruction will set user from which all RUN, CMD and ENTRYPOINT commands will run.\nWORKDIR WORKDIR \u0026lt;path\u0026gt;\nWORKDIR will set current working directory for all RUN, CMD, ENTRYPOINT, COPY and ADD commands.\nONBUILD ONBUILD \u0026lt;dockerfile_command\u0026gt;\nONBUILD will trigger only if current image will be used as base image to build a new one. After ONBUILD we can specify any of the instructions explained below.\nExample Build process for our Dockerfile With file described below and other needed file in build context directory:\n[node1] (local) root@192.168.0.18 ~/postgres-build-dir $ ls -lah total 12K drwxr-xr-x 2 root root 76 Feb 28 16:14 . drwx------ 1 root root 48 Feb 28 16:14 .. -rw-r--r-- 1 root root 1.3K Feb 28 16:14 Dockerfile -rw-r--r-- 1 root root 99 Feb 28 16:15 docker-entrypoint.sh -rw-r--r-- 1 root root 40 Feb 28 16:15 my-yum-repo.repo Always have in context directory only necessary files for build process!\nAll this files will be transferred to docker daemon and could make your new image huge!\nWe can build postgresql image - notice that we are using --build-arg to overwrite default 11.5 version specified in dockerfile - let\u0026rsquo;s say that we need 11.6:\n[node1] (local) root@192.168.0.18 ~/postgres-build-dir $ docker build -t postgresql-server:11.6 --build-arg PG_MINOR=6 . Sending build context to Docker daemon 5.12kB Step 1/28 : FROM centos:7 7: Pulling from library/centos ab5ef0e58194: Extracting 75.78MB/75.78MB [..] ","href":"/posts/docker_build_from_dockerfile/","title":"Docker build from dockerfile - compendium"},{"content":"","href":"/tags/dockerfile/","title":"dockerfile"},{"content":"","href":"/tags/postgresql/","title":"postgresql"},{"content":"Hi! My name is ukasz Bartnicki. I\u0026rsquo;m database administrator from Poland.\nOn daily basis I\u0026rsquo;m working mainly with Oracle Database but also PostgreSQL and many things around that technologies.\nIf you want to contact me, feel free to communicate by Linkedin - link to my profile at bottom of the site.\nWhy I created this site? What is aim of it? Good administrator or DevOps has to got his personal notes. It is very important especially in database world where some procedures can be long and hard to remember - creating such site will help me to order my notes and give me possibility to be more effective at my work.\nSince I already making some notes, why not make they public? Maybe it will help someone at Admin/DevOps work.\nObjective is simple. Content created here will be essence of knowledge taken from documentation of IT software, other internet sources and my home lab. There will be no unnecessary theory but focus on solving practical problems.\nFeel free to share links from this site.\n","href":"/about/","title":"About me"},{"content":"What are you looking for?\n","href":"/search/","title":""},{"content":"","href":"/series/","title":"Series"}]
