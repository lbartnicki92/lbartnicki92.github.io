[{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/categories/docker/","title":"docker"},{"content":"","href":"/tags/docker-image/","title":"docker image"},{"content":"Docker has got couple commands that allows us to manage images.\nList images Usage of docker image ls is described in another post: Docker image - list\nRemove images Let\u0026rsquo;s check what images we have locally:\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 8 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB We have ubuntu image that has got two aliases: ubuntu:latest and ubuntu:18.04\nLet\u0026rsquo;s remove one of it:\n[root@docker-host ~]# docker image rm ubuntu:18.04 Untagged: ubuntu:18.04 [root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 8 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB As we saw docker image rm removed only alias - if we remove last image alias - image will be deleted also - precisely layers that are no longer needed:\n[root@docker-host ~]# docker image rm ubuntu:latest Untagged: ubuntu:latest Untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d Deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd Deleted: sha256:1d9112746e9d86157c23e426ce87cc2d7bced0ba2ec8ddbdfbcc3093e0769472 Deleted: sha256:efcf4a93c18b5d01aa8e10a2e3b7e2b2eef0378336456d8653e2d123d6232c1e Deleted: sha256:1e1aa31289fdca521c403edd6b37317bf0a349a941c7f19b6d9d311f59347502 Deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853 Normally docker doesn\u0026rsquo;t allow us to delete image from which containers are currently running. We can use --force in remove command but it will remove also containers.\nRemove dandling and unused images We can remove dandling(without repository and tag) images with docker image prune. In our example all images has got repository and tag so none of them will be removed.\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 8 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB [root@docker-host ~]# docker image prune WARNING! This will remove all dangling images. Are you sure you want to continue? [y/N] y Total reclaimed space: 0B We can use -a parameter to remove all images not associated with containers.\nI dont\u0026rsquo; have any containers in example so all images should be deleted by this command.\n[root@docker-host ~]# docker image prune -a WARNING! This will remove all images without at least one container associated to them. Are you sure you want to continue? [y/N] y Deleted Images: untagged: schickling/postgres-backup-s3:latest untagged: schickling/postgres-backup-s3@sha256:77fb08dff3a07d850ba88fd072e9f2938f8dd5e267411238fd9814ccec14a34f deleted: sha256:e8e41fa54edbb0e98f4ef20edfdca3f83732b084d4a7524ea87544ff030b4605 [...] deleted: sha256:cd7100a72410606589a54b932cabd804a17f9ae5b42a1882bd56d263e02b6215 untagged: ubuntu:18.04 untagged: ubuntu@sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d deleted: sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd [...] deleted: sha256:c8be1b8f4d60d99c281fc2db75e0f56df42a83ad2f0b091621ce19357e19d853 untagged: postgres:latest untagged: postgres@sha256:d480b197ab8e01edced54cbbbba9707373473f42006468b60be04da07ce97823 deleted: sha256:9907cacf0c01916f9cd5fef24ae0daf564098afe0f7904962b9cb99758823461 deleted: sha256:736efdcf1e7318755b2ea260d89a859e8d7f8614f9746fcb092e8cbc66a0849f [...] deleted: sha256:c3a984abe8a88059915bb6c7a1d249fd1ccc16d931334ac8816540b0eb686b45 untagged: alpine:latest untagged: alpine@sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239 deleted: sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72 deleted: sha256:beee9f30bc1f711043e78d4a2be0668955d4b761d587d6f60c2c8dc081efb203 untagged: ubuntu:19.04 untagged: ubuntu@sha256:2adeae829bf27a3399a0e7db8ae38d5adb89bcaf1bbef378240bc0e6724e8344 deleted: sha256:c88ac1f841b72add46f5a8b0e77c2ad6864d47e5603686ea64375acd55e27906 [...] deleted: sha256:873cbe4bd21ee6f6ea264cfc50c0b35b0c3a00e2be3f82b30884c3b9da5db2db Total reclaimed space: 570.3MB Like in docker image ls --filter parameters works here, more about it in: Docker image - list\nCheck image build steps [root@docker-host ~]# docker image history 4e5021d210f6 IMAGE CREATED CREATED BY SIZE COMMENT 4e5021d210f6 2 weeks ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/bash\u0026#34;] 0B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c mkdir -p /run/systemd \u0026amp;\u0026amp; echo \u0026#39;do… 7B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c set -xe \u0026amp;\u0026amp; echo \u0026#39;#!/bin/sh\u0026#39; \u0026gt; /… 745B \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c [ -z \u0026#34;$(apt-get indextargets)\u0026#34; ] 987kB \u0026lt;missing\u0026gt; 2 weeks ago /bin/sh -c #(nop) ADD file:594fa35cf803361e6… 63.2MB We see that intermediate layers have got \u0026lt;missing\u0026gt; image id - this id\u0026rsquo;s was removed because of moving image within different hosts. There are no longer by build cache.\nBy default commands are truncated but it is possibility to extend them to full size by adding --no-trunc parameter.\nInspect images To view metadata about image we can use docker image inspect command:\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [root@docker-host ~]# docker image inspect a187dde48cd2 [ { \u0026#34;Id\u0026#34;: \u0026#34;sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72\u0026#34;, \u0026#34;RepoTags\u0026#34;: [ \u0026#34;alpine:latest\u0026#34; ], \u0026#34;RepoDigests\u0026#34;: [ \u0026#34;alpine@sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239\u0026#34; ], \u0026#34;Parent\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Comment\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2020-03-23T21:19:34.196162891Z\u0026#34;, \u0026#34;Container\u0026#34;: \u0026#34;fb71ddde5f6411a82eb056a9190f0cc1c80d7f77a8509ee90a2054428edb0024\u0026#34;, \u0026#34;ContainerConfig\u0026#34;: { \u0026#34;Hostname\u0026#34;: \u0026#34;fb71ddde5f64\u0026#34;, \u0026#34;Domainname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;User\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AttachStdin\u0026#34;: false, \u0026#34;AttachStdout\u0026#34;: false, \u0026#34;AttachStderr\u0026#34;: false, \u0026#34;Tty\u0026#34;: false, \u0026#34;OpenStdin\u0026#34;: false, \u0026#34;StdinOnce\u0026#34;: false, \u0026#34;Env\u0026#34;: [ \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; ], \u0026#34;Cmd\u0026#34;: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;#(nop) \u0026#34;, \u0026#34;CMD [\\\u0026#34;/bin/sh\\\u0026#34;]\u0026#34; ], \u0026#34;ArgsEscaped\u0026#34;: true, \u0026#34;Image\u0026#34;: \u0026#34;sha256:74df73bb19fbfc7fb5ab9a8234b3d98ee2fb92df5b824496679802685205ab8c\u0026#34;, \u0026#34;Volumes\u0026#34;: null, \u0026#34;WorkingDir\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Entrypoint\u0026#34;: null, \u0026#34;OnBuild\u0026#34;: null, \u0026#34;Labels\u0026#34;: {} }, \u0026#34;DockerVersion\u0026#34;: \u0026#34;18.09.7\u0026#34;, \u0026#34;Author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Config\u0026#34;: { \u0026#34;Hostname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Domainname\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;User\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;AttachStdin\u0026#34;: false, \u0026#34;AttachStdout\u0026#34;: false, \u0026#34;AttachStderr\u0026#34;: false, \u0026#34;Tty\u0026#34;: false, \u0026#34;OpenStdin\u0026#34;: false, \u0026#34;StdinOnce\u0026#34;: false, \u0026#34;Env\u0026#34;: [ \u0026#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; ], \u0026#34;Cmd\u0026#34;: [ \u0026#34;/bin/sh\u0026#34; ], \u0026#34;ArgsEscaped\u0026#34;: true, \u0026#34;Image\u0026#34;: \u0026#34;sha256:74df73bb19fbfc7fb5ab9a8234b3d98ee2fb92df5b824496679802685205ab8c\u0026#34;, \u0026#34;Volumes\u0026#34;: null, \u0026#34;WorkingDir\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Entrypoint\u0026#34;: null, \u0026#34;OnBuild\u0026#34;: null, \u0026#34;Labels\u0026#34;: null }, \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Os\u0026#34;: \u0026#34;linux\u0026#34;, \u0026#34;Size\u0026#34;: 5595566, \u0026#34;VirtualSize\u0026#34;: 5595566, \u0026#34;GraphDriver\u0026#34;: { \u0026#34;Data\u0026#34;: { \u0026#34;MergedDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/d005a98ba83c1d08b18a3d1b22470146b1ccd6541e6132691d746441b3f378f2/merged\u0026#34;, \u0026#34;UpperDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/d005a98ba83c1d08b18a3d1b22470146b1ccd6541e6132691d746441b3f378f2/diff\u0026#34;, \u0026#34;WorkDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/d005a98ba83c1d08b18a3d1b22470146b1ccd6541e6132691d746441b3f378f2/work\u0026#34; }, \u0026#34;Name\u0026#34;: \u0026#34;overlay2\u0026#34; }, \u0026#34;RootFS\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;layers\u0026#34;, \u0026#34;Layers\u0026#34;: [ \u0026#34;sha256:beee9f30bc1f711043e78d4a2be0668955d4b761d587d6f60c2c8dc081efb203\u0026#34; ] }, \u0026#34;Metadata\u0026#34;: { \u0026#34;LastTagTime\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34; } } ] Tag images We can change image name(repository and tag) by docker image tag command:\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [root@docker-host ~]# docker image tag alpine:latest alpine-lukas:1.0 [root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine-lukas 1.0 a187dde48cd2 2 weeks ago 5.6MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB In previous example we create another image(it is alias because of smart storage management in Docker).\nIf we want prepare image for sending remotely we can add repository name, later we can push this image to remote registry:\n[root@docker-host ~]# docker image tag alpine-lukas:1.0 registry.lukas.it/alpine-lukas:1.0 [root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE alpine-lukas 1.0 a187dde48cd2 2 weeks ago 5.6MB alpine latest a187dde48cd2 2 weeks ago 5.6MB registry.lukas.it/alpine-lukas 1.0 a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ","href":"/posts/docker_image_commands/","title":"Docker image - commands"},{"content":"","href":"/","title":"IT Knowledge Pill"},{"content":"","href":"/authors/lbartnicki/","title":"lbartnicki"},{"content":"","href":"/posts/","title":"Posts"},{"content":"","href":"/tags/","title":"Tags"},{"content":"Docker has got couple commands that allows us to manage images. Mostly we are getting list of images.\nBasic listing Basic images listing with command: docker image ls.\nSize is cumulative value from all layers needed for image.\nBelow images are local images without repository specified.\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Searching for specific image in local repo on host.\nWorks also with tag eg.: docker image ls ubuntu:18.04\n[root@docker-host ~]# docker image ls ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB Without truncating output: [root@docker-host ~]# docker image ls --no-trunc postgres latest sha256:9907cacf0c01916f9cd5fef24ae0daf564098afe0f7904962b9cb99758823461 6 days ago 314MB alpine latest sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72 2 weeks ago 5.6MB ubuntu 18.04 sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd 2 weeks ago 64.2MB ubuntu latest sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd 2 weeks ago 64.2MB ubuntu 19.04 sha256:c88ac1f841b72add46f5a8b0e77c2ad6864d47e5603686ea64375acd55e27906 2 months ago 70MB Quiet mode Useful if we need only image ID for script or another command:\n[root@docker-host ~]# docker image ls -q 9907cacf0c01 a187dde48cd2 4e5021d210f6 4e5021d210f6 c88ac1f841b7 Listing with digest hash Digest is sha256 hash. If two images has got same digest hash, they have got the same content.\nBelow we have three images of ubuntu. From digest we get information that latest image and 18.04 are the same.\nSo if you pull ubuntu:latest, you get ubuntu:18.04\n[root@docker-host ~]# docker image ls --digests REPOSITORY TAG DIGEST IMAGE ID CREATED SIZE postgres latest sha256:d480b197ab8e01edced54cbbbba9707373473f42006468b60be04da07ce97823 9907cacf0c01 6 days ago 314MB alpine latest sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239 a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 sha256:2adeae829bf27a3399a0e7db8ae38d5adb89bcaf1bbef378240bc0e6724e8344 c88ac1f841b7 2 months ago 70MB Filtering images Get images without tags Images without tags are called dandling.\nThis type of images is created when we build or tag image with [REPOSITORY[:TAG]] name of existing image.\nNew image gets [REPOSITORY[:TAG]], old one get name: [NONE[:NONE]]\n[root@docker-host ~]# docker images --filter \u0026#34;dangling=true\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE [root@docker-host ~]# docker images --filter \u0026#34;dangling=false\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Get images by labels In example, we search for every image with maintaner label set(I pulled this image additionally because none of official ubuntu and postgres images has got label added):\n[root@docker-host ~]# docker image ls --filter \u0026#34;label=maintainer\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB Get images created before another image We can insted of before use since for images created after given image.\n[root@docker-host ~]# docker image ls --filter \u0026#34;before=ubuntu:19.04\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB [root@docker-host ~]# docker image ls --filter \u0026#34;before=postgres:latest\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB Wildcard search [root@docker-host ~]# docker image ls --filter=reference=\u0026#39;*:latest\u0026#39; REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [root@docker-host ~]# docker image ls --filter=reference=\u0026#39;ubuntu:*.04\u0026#39; REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Pretty output format [root@docker-host ~]# docker image ls --format \u0026#34;{{.ID}}\u0026#34; 9907cacf0c01 a187dde48cd2 4e5021d210f6 4e5021d210f6 c88ac1f841b7 e8e41fa54edb [root@k8s-master ~]# docker image ls --format \u0026#34;{{.ID}}:{{.Tag}}\u0026#34; 9907cacf0c01:latest a187dde48cd2:latest 4e5021d210f6:18.04 4e5021d210f6:latest c88ac1f841b7:19.04 e8e41fa54edb:latest [root@k8s-master ~]# docker image ls --format \u0026#34;Image {{.ID}} has got tag {{.Tag}}\u0026#34; Image 9907cacf0c01 has got tag latest Image a187dde48cd2 has got tag latest Image 4e5021d210f6 has got tag 18.04 Image 4e5021d210f6 has got tag latest Image c88ac1f841b7 has got tag 19.04 Image e8e41fa54edb has got tag latest Options list  .ID\t- Image ID .Repository\t- Image repository .Tag- Image tag .Digest -\tImage digest .CreatedSince -\tElapsed time since the image was created .CreatedAt - Time when the image was created .Size -\tImage disk size  ","href":"/posts/docker_image_listing/","title":"Docker image - list"},{"content":"","href":"/tags/kubeconfig/","title":"KUBECONFIG"},{"content":"","href":"/tags/kubectl/","title":"kubectl"},{"content":"Kubectl client gives us possibility to configure and switch easy between multiple K8s clusters.\nConfig files location for kubectl Main location for kubectl config files is $HOME/.kube, by default we have single config file named config:\n[node1 ~]$ cd $HOME/.kube [node1 .kube]$ ls -lah total 4.0K drwxr-xr-x 1 root root 37 Mar 12 20:48 . dr-xr-x--- 1 root root 19 Nov 29 11:46 .. drwxr-x--- 3 root root 23 Mar 12 20:48 cache lrwxrwxrwx 1 root root 26 Nov 29 11:46 config -\u0026gt; /etc/kubernetes/admin.conf drwxr-x--- 3 root root 4.0K Mar 12 20:48 http-cache Multiple config files and KUBECONFIG variable We can have multiple config files by setting proper KUBECONFIG shell variable.\nFor example:\nexport KUBECONFIG=$KUBECONFIG:/root/.kube/additional_config\nCheck config from kubectl We can check current config(it will be empty because I don\u0026rsquo;t have anything in additional_config file - we\u0026rsquo;ll add something later - and this is only file in my KUBECONFIG variable):\n[node1 ~]$ kubectl config view apiVersion: v1 clusters: [] contexts: [] current-context: \u0026#34;\u0026#34; kind: Config preferences: {} users: [] Or from specific file - let\u0026rsquo;s see default file:\n[node1 ~]$ kubectl config --kubeconfig=.kube/config view apiVersion: v1 clusters: - cluster: certificate-authority-data: DATA+OMITTED server: https://192.168.0.38:6443 name: kubernetes contexts: - context: cluster: kubernetes user: kubernetes-admin name: kubernetes-admin@kubernetes current-context: kubernetes-admin@kubernetes kind: Config preferences: {} users: - name: kubernetes-admin user: client-certificate-data: REDACTED client-key-data: REDACTED If you don\u0026rsquo;t set KUBECONFIG variable all configuration will be taken from $HOME/.kube/config\nObjects in kubectl config kubectl has in his config files following object types:\n clusters - info about K8s cluster - contain cluster name and connection parameters users - info about users by which you want connect to K8s clusters contexts - triple of cluster/user/namespace  Modifying config from kubectl Add cluster [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-cluster dev --server=https://192.168.1.100 --certificate-authority=fake-ca Cluster \u0026#34;dev\u0026#34; set. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-cluster prod --server=https://10.1.1.100 --certificate-authority=fake-ca Cluster \u0026#34;prod\u0026#34; set. Add users [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-credentials developer --client-certificate=fake-cert-file --client-key=fake-key-seefile User \u0026#34;developer\u0026#34; set. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-credentials prod_admin --client-certificate=fake-cert-file --client-key=fake-key-seefile User \u0026#34;prod_admin\u0026#34; set. Add contexts [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-context simple_app_development --cluster=dev --namespace=simple_app_dev --user=developer Context \u0026#34;simple_app_development\u0026#34; created. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-context simple_app_production --cluster=prod --namespace=simple_app_prod --user=prod_admin Context \u0026#34;simple_app_production\u0026#34; created. Delete cluster/user/context from config kubectl --kubeconfig=.kube/additional_config config unset users.\u0026lt;name\u0026gt; kubectl --kubeconfig=.kube/additional_config config unset clusters.\u0026lt;name\u0026gt; kubectl --kubeconfig=.kube/additional_config config unset contexts.\u0026lt;name\u0026gt; Sample config [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config view apiVersion: v1 clusters: - cluster: certificate-authority: /root/fake-ca server: https://192.168.1.100 name: dev - cluster: certificate-authority: /root/fake-ca server: https://10.1.1.100 name: prod contexts: - context: cluster: dev namespace: simple_app_dev user: developer name: simple_app_development - context: cluster: prod namespace: simple_app_prod user: prod_admin name: simple_app_production current-context: \u0026#34;\u0026#34; kind: Config preferences: {} users: - name: developer user: client-certificate: /root/fake-cert-file client-key: /root/fake-key-seefile - name: prod_admin user: client-certificate: /root/fake-cert-file client-key: /root/fake-key-seefile Changing context we working with To get list of contexts(no need for --kubeconfig because we have our additional_config added to KUBECONFIG variable):\n[node1 ~]$ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE simple_app_development dev developer simple_app_dev simple_app_production prod prod_admin simple_app_prod To set context:\n[node1 ~]$ kubectl config use-context simple_app_development Switched to context \u0026#34;simple_app_development\u0026#34;. To get current context:\n[node1 ~]$ kubectl config current-context simple_app_development ","href":"/posts/kubernetes_kubectl_client_config/","title":"Kubectl - configuration"},{"content":"","href":"/categories/kubernetes/","title":"kubernetes"},{"content":"","href":"/tags/docker-build/","title":"docker build"},{"content":"All docker containers are started from an image.\nWhat\u0026rsquo;s an image? Image is a collection of read only layers with everything we need to run application. Commonly in image we have base layout of operating system we had choose and some necessary binaries to start our application.\nFor exaple, for PostgreSQL container image could contain CentOS base filesystem template, PostgreSQL binaries and some configuration files.\nHow we build image? We build image by issuing command docker build, but before we use it we need to create a Docker file.\nSimplest-minimal command to build image:\ndocker build -t postgresql-server:11.6 .\nWe just use -t for setting image name and tag.\nDot at the end means that for build context we choose current dir - we could specify here full path to build context directory, which should provide Dockerfile and other files that we want to copy into our image at building process.\nAnother important docker build parameters are:\n --pull - Always pull a newer version of the image from which we build --no-cache - disable layer build cache --build-arg - send to docker daemon values for parameters from Dockerfile --file - choose custom Dockerfile location(out of build context directory)  For complete list check docker build -h\nBefore we use below command first we have to prepair Dockerfile.\nWhat is a Dockerfile? Dockerfile is text file with all commands needed to create environment for our application. We can easly define what files we want to include in our image, what binaries will run in container or what ports we want to expose from it. Using Dockerfile gives us possibility to fast create multiple enviroments just by modifying file and reissuing docker build.\nAssume that we have our java application in 0.1 version currently running - we get from dev team 0.2. Only thing we have to do is to change in Dockerfile path to jar file(or if we put app version in variable use parameter --build-arg - later about it in sample) and issue docker build - of course we should provide proper name for new image which will reflect app version. After image build we can start container with new application.\nSample Dockerfile FROMcentos:7LABEL maintainer=\u0026#34;lukas@mail.com\u0026#34;ARG PG_MAJORARG PG_MINORENV PG_MAJOR=${PG_MAJOR:-11}ENV PG_MINOR=${PG_MINOR:-5}ENV PG_PORT 5432ENV PG_USER_ID 2201ENV PG_USER_GID 2201ENV PG_ENCODING UTF8ENV PG_LOCALE en_US.UTF8ENV PG_AUTH md5ENV PG_AUTH_HOST md5ENV PG_AUTH_LOCAL md5RUN groupadd -g ${PG_USER_GID} postgres; useradd -g ${PG_USER_GID} -u ${PG_USER_ID} postgresCOPY my-yum-repo.repo /etc/yum.repos.d/RUN yum update -y; \\  yum -y install \\  postgresql11-server-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-contrib-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-libs-${PG_MAJOR}.${PG_MINOR}; \\  yum clean all;ENV PATH $PATH:/usr/pgsql-${PG_MAJOR}/binENV PG_DIR /postgresqlENV PG_DATA ${PG_DIR}/data/pg${PG_MAJOR}ENV WAL_DATA ${PG_DIR}/walRUN set -ex; \\  mkdir -p ${PG_DIR}; \\  mkdir -p ${PG_DATA}; \\  mkdir -p ${WAL_DATA}; \\  mkdir -p ${PG_DIR}/archive; \\  mkdir -p ${PG_DIR}/backup; \\  mkdir -p ${PG_DIR}/log; \\  mkdir -p ${PG_DIR}/pgsql; \\  mkdir -p ${PG_DIR}/tmp; \\  chown -R postgres:postgres ${PG_DIR}; \\  chmod 750 -R ${PG_DIR};VOLUME${PG_DIR}VOLUME${WAL_DATA}COPY docker-entrypoint.sh /usr/local/binRUN chmod u+x /usr/local/bin/docker-entrypoint.shENTRYPOINT [\u0026#34;/usr/local/bin/docker-entrypoint.sh\u0026#34;]EXPOSE5432What commands in Dockerfile we have? FROM FROM [--platform=\u0026lt;platform\u0026gt;] \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;]\nFROM centos7\nFROM tells Docker Engine which image it has to use as base image for current build.\n[--platform=\u0026lt;platform\u0026gt;] flag can be used to specify the platform of the image when we are building multi-platform image. For example, linux/amd64. By default image is build with platform on which build is triggered.\n[AS \u0026lt;name\u0026gt;] clause is used for creating multi stage builds. I will cover this topic in another post.\nIn example we use CentOS operating system, we didn\u0026rsquo;t specified any tag because we want newest CentOS image for version 7.\nEvery command under FROM directive will be run on base image. It\u0026rsquo;s important to notice that we don\u0026rsquo;t have to use as base images OS image. We can use any correctly build image, and build on top of it.\nIt is possible to parametrize image version specified in FROM clause with ARG and --build-arg.\nARG ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;]\nARG PG_MAJOR\nARG PG_MINOR\nARG clause define build time variable.\nWe can pass parameters for it with --build-arg for docker build also we can specify default value for it in case of omitting in --build-arg by doing like ARG PG_MINOR=11.\nThis variables are available only at build time!\nIn our example we user ARG for PostgreSQL version. By doing so, we can build from one Dockerfile multiple images with different PostgreSQL engines. We can use ARG before FROM for parametrizing version of base image.\nENV ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\nENV PG_PORT 5432\nENV clause define runtime variable.\nIn form without = sign - all characters after name of variable are treat as one string including whitespaces. The ENV variables will persist when a container is run. We can change them using docker run --env \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; on next container start.\nARG/ENV trick ARG PG_MAJOR\nARG PG_MINOR\nENV PG_MAJOR=${PG_MAJOR:-11}\nENV PG_MINOR=${PG_MINOR:-5}\nWhy we do something like this?\nAs mentioned, ENV - runtime variable, ARG build variable which can\u0026rsquo;t be accessed at container runtime.\nIn our example, we want to modify version of PostgreSQL which we will use at build time, but what if after build we need this variable values for some operations which can happen in some scripts in our container?\nTo persist this variables and make them available in running container we make ARG variables without default. Later we use them to set ENV's. Also we move default values set to ENV(shell syntax for setting default value).\nNow we can manipulate values with docker build --build-arg, but we also have them available after build at running container.\nLABEL LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\nLABEL maintainer=\u0026quot;lukas@mail.com\u0026quot;\nLABEL is used for adding some metadata to image which we will be visible in docker inspect output.\nIn example we add info about image building person.\nWe can specify multiple labels - in multiple or one line.\nRUN RUN \u0026lt;command\u0026gt;\nRUN [\u0026quot;exec\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\nRUN chmod u+x /usr/local/bin/docker-entrypoint.sh\nRUN execute command on operating system of container.\nIf you just give command after RUN it will be execute in shell - for Linux it will be probably bash. If you use [](JSON form) it will execute command in raw mode - without shell characteristic behaviours. You should remember to use \u0026quot;\u0026rdquo; around each part of command.\nEach RUN command creates new layer in image. Lesser layers, the better. Always try to merge multiple commands making some logical unit of work into one RUN statement.\nFor example, appending to file, moving it and changing permissions.\nUse for it shell syntax like RUN \u0026lt;command\u0026gt;; \u0026lt;command2\u0026gt;; \u0026lt;command3\u0026gt; in Linux.\nCOPY \u0026amp; ADD ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\nCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\nCOPY my-yum-repo.repo /etc/yum.repos.d/\nADD and COPY command will move files or directories from src to dest. In most cases COPY is command you need. ADD will be used only when you want to copy from URL - that is main difference between them, COPY don\u0026rsquo;t work over network - just local files.\nIn both cases build context is your \u0026ldquo;root\u0026rdquo; path from which you can use relative paths like somefolder/somefolder2/somefile\nIn both cases you can use wildcards like * or ?.\nIn both cases you can use [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] parameter to set owner and group for things that you place into image.\nVOLUME VOLUME [\u0026quot;\u0026lt;path\u0026gt;\u0026quot;]\nVOLUME ${PG_DIR}\nVOLUME creates mount point in filesystem of container for external volumes.\nENTRYPOINT \u0026amp; COMMAND ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\nENTRYPOINT [\u0026quot;/usr/local/bin/docker-entrypoint.sh\u0026quot;]\nENTRYPOINT defines binary or shell script which will start immediately after starting container.\nIn our example we have docker-entrypoint.sh script which can contain logic like: if $PG_DATA empty initialize new postgresql cluster with initdb, if not empty - start postgresql with /usr/bin/postgres -D $PG_DATA.\nWe can pass arguments to ENTRYPOINT by adding it to docker run after image name.\nCOMMAND clause will be support command for ENTRYPOINT - it will hold default parameters for binary started in ENTRYPOINT in case when they are must exists and we do not pass anything to docker run. In our example there isn\u0026rsquo;t need for using COMMAND.\nIt is possible to override ENTRYPOINT when starting container with docker run --entrypoint parameter.\nEXPOSE EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;/\u0026lt;protocol\u0026gt;]\nEXPOSE 5432\nEXPOSE is documentation command that shows at which ports services in container will listen.\nUSER USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;]\nUSER instruction will set user from which all RUN, CMD and ENTRYPOINT commands will run.\nWORKDIR WORKDIR \u0026lt;path\u0026gt;\nWORKDIR will set current working directory for all RUN, CMD, ENTRYPOINT, COPY and ADD commands.\nONBUILD ONBUILD \u0026lt;dockerfile_command\u0026gt;\nONBUILD will trigger only if current image will be used as base image to build a new one. After ONBUILD we can specify any of the instructions explained below.\nExample Build process for our Dockerfile With file described below and other needed file in build context directory:\n[node1] (local) root@192.168.0.18 ~/postgres-build-dir $ ls -lah total 12K drwxr-xr-x 2 root root 76 Feb 28 16:14 . drwx------ 1 root root 48 Feb 28 16:14 .. -rw-r--r-- 1 root root 1.3K Feb 28 16:14 Dockerfile -rw-r--r-- 1 root root 99 Feb 28 16:15 docker-entrypoint.sh -rw-r--r-- 1 root root 40 Feb 28 16:15 my-yum-repo.repo Always have in context directory only necessary files for build process!\nAll this files will be transferred to docker daemon and could make your new image huge!\nWe can build postgresql image - notice that we are using --build-arg to overwrite default 11.5 version specified in dockerfile - let\u0026rsquo;s say that we need 11.6:\n[node1] (local) root@192.168.0.18 ~/postgres-build-dir $ docker build -t postgresql-server:11.6 --build-arg PG_MINOR=6 . Sending build context to Docker daemon 5.12kB Step 1/28 : FROM centos:7 7: Pulling from library/centos ab5ef0e58194: Extracting 75.78MB/75.78MB [..] ","href":"/posts/docker_build_from_dockerfile/","title":"Docker build from dockerfile - compendium"},{"content":"","href":"/tags/dockerfile/","title":"dockerfile"},{"content":"","href":"/tags/postgresql/","title":"postgresql"},{"content":"What are you looking for?\n","href":"/search/","title":""},{"content":"","href":"/series/","title":"Series"}]
