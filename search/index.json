[{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/categories/docker/","title":"docker"},{"content":"","href":"/tags/docker-image/","title":"docker image"},{"content":"Docker has got couple commands that allows us to manage images. Mostly we are getting list of images.\nBasic listing Basic images listing with command: docker image ls.\nSize is cumulative value from all layers needed for image.\nBelow images are local images without repository specified.\n[root@docker-host ~]# docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Searching for specific image in local repo on host.\nWorks also with tag eg.: docker image ls ubuntu:18.04\n[root@docker-host ~]# docker image ls ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB Without truncating output: [root@docker-host ~]# docker image ls --no-trunc postgres latest sha256:9907cacf0c01916f9cd5fef24ae0daf564098afe0f7904962b9cb99758823461 6 days ago 314MB alpine latest sha256:a187dde48cd289ac374ad8539930628314bc581a481cdb41409c9289419ddb72 2 weeks ago 5.6MB ubuntu 18.04 sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd 2 weeks ago 64.2MB ubuntu latest sha256:4e5021d210f65ebe915670c7089120120bc0a303b90208592851708c1b8c04bd 2 weeks ago 64.2MB ubuntu 19.04 sha256:c88ac1f841b72add46f5a8b0e77c2ad6864d47e5603686ea64375acd55e27906 2 months ago 70MB Quiet mode Useful if we need only image ID for script or another command:\n[root@docker-host ~]# docker image ls -q 9907cacf0c01 a187dde48cd2 4e5021d210f6 4e5021d210f6 c88ac1f841b7 Listing with digest hash Digest is sha256 hash. If two images has got same digest hash, they have got the same content.\nBelow we have three images of ubuntu. From digest we get information that latest image and 18.04 are the same.\nSo if you pull ubuntu:latest, you get ubuntu:18.04\n[root@docker-host ~]# docker image ls --digests REPOSITORY TAG DIGEST IMAGE ID CREATED SIZE postgres latest sha256:d480b197ab8e01edced54cbbbba9707373473f42006468b60be04da07ce97823 9907cacf0c01 6 days ago 314MB alpine latest sha256:b276d875eeed9c7d3f1cfa7edb06b22ed22b14219a7d67c52c56612330348239 a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 sha256:2adeae829bf27a3399a0e7db8ae38d5adb89bcaf1bbef378240bc0e6724e8344 c88ac1f841b7 2 months ago 70MB Filtering images Get images without tags Images without tags are called dandling.\nThis type of images is created when we build or tag image with [REPOSITORY[:TAG]] name of existing image.\nNew image gets [REPOSITORY[:TAG]], old one get name: [NONE[:NONE]]\n[root@docker-host ~]# docker images --filter \u0026#34;dangling=true\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE [root@docker-host ~]# docker images --filter \u0026#34;dangling=false\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Get images by labels In example, we search for every image with maintaner label set(I pulled this image additionally because none of official ubuntu and postgres images has got label added):\n[root@docker-host ~]# docker image ls --filter \u0026#34;label=maintainer\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB Get images created before another image We can insted of before use since for images created after given image.\n[root@docker-host ~]# docker image ls --filter \u0026#34;before=ubuntu:19.04\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB [root@docker-host ~]# docker image ls --filter \u0026#34;before=postgres:latest\u0026#34; REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB schickling/postgres-backup-s3 latest e8e41fa54edb 21 months ago 117MB Wildcard search [root@docker-host ~]# docker image ls --filter=reference=\u0026#39;*:latest\u0026#39; REPOSITORY TAG IMAGE ID CREATED SIZE postgres latest 9907cacf0c01 6 days ago 314MB alpine latest a187dde48cd2 2 weeks ago 5.6MB ubuntu latest 4e5021d210f6 2 weeks ago 64.2MB [root@docker-host ~]# docker image ls --filter=reference=\u0026#39;ubuntu:*.04\u0026#39; REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 4e5021d210f6 2 weeks ago 64.2MB ubuntu 19.04 c88ac1f841b7 2 months ago 70MB Pretty output format [root@docker-host ~]# docker image ls --format \u0026#34;{{.ID}}\u0026#34; 9907cacf0c01 a187dde48cd2 4e5021d210f6 4e5021d210f6 c88ac1f841b7 e8e41fa54edb [root@k8s-master ~]# docker image ls --format \u0026#34;{{.ID}}:{{.Tag}}\u0026#34; 9907cacf0c01:latest a187dde48cd2:latest 4e5021d210f6:18.04 4e5021d210f6:latest c88ac1f841b7:19.04 e8e41fa54edb:latest [root@k8s-master ~]# docker image ls --format \u0026#34;Image {{.ID}} has got tag {{.Tag}}\u0026#34; Image 9907cacf0c01 has got tag latest Image a187dde48cd2 has got tag latest Image 4e5021d210f6 has got tag 18.04 Image 4e5021d210f6 has got tag latest Image c88ac1f841b7 has got tag 19.04 Image e8e41fa54edb has got tag latest Options list  .ID\t- Image ID .Repository\t- Image repository .Tag- Image tag .Digest -\tImage digest .CreatedSince -\tElapsed time since the image was created .CreatedAt - Time when the image was created .Size -\tImage disk size  ","href":"/posts/docker_image_listing/","title":"Docker image listing"},{"content":"","href":"/","title":"IT Knowledge Pill"},{"content":"","href":"/authors/lbartnicki/","title":"lbartnicki"},{"content":"","href":"/posts/","title":"Posts"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/tags/kubeconfig/","title":"KUBECONFIG"},{"content":"","href":"/tags/kubectl/","title":"kubectl"},{"content":"Kubectl client gives us possibility to configure and switch easy between multiple K8s clusters.\nConfig files location for kubectl Main location for kubectl config files is $HOME/.kube, by default we have single config file named config:\n[node1 ~]$ cd $HOME/.kube [node1 .kube]$ ls -lah total 4.0K drwxr-xr-x 1 root root 37 Mar 12 20:48 . dr-xr-x--- 1 root root 19 Nov 29 11:46 .. drwxr-x--- 3 root root 23 Mar 12 20:48 cache lrwxrwxrwx 1 root root 26 Nov 29 11:46 config -\u0026gt; /etc/kubernetes/admin.conf drwxr-x--- 3 root root 4.0K Mar 12 20:48 http-cache Multiple config files and KUBECONFIG variable We can have multiple config files by setting proper KUBECONFIG shell variable.\nFor example:\nexport KUBECONFIG=$KUBECONFIG:/root/.kube/additional_config\nCheck config from kubectl We can check current config(it will be empty because I don\u0026rsquo;t have anything in additional_config file - we\u0026rsquo;ll add something later - and this is only file in my KUBECONFIG variable):\n[node1 ~]$ kubectl config view apiVersion: v1 clusters: [] contexts: [] current-context: \u0026#34;\u0026#34; kind: Config preferences: {} users: [] Or from specific file - let\u0026rsquo;s see default file:\n[node1 ~]$ kubectl config --kubeconfig=.kube/config view apiVersion: v1 clusters: - cluster: certificate-authority-data: DATA+OMITTED server: https://192.168.0.38:6443 name: kubernetes contexts: - context: cluster: kubernetes user: kubernetes-admin name: kubernetes-admin@kubernetes current-context: kubernetes-admin@kubernetes kind: Config preferences: {} users: - name: kubernetes-admin user: client-certificate-data: REDACTED client-key-data: REDACTED If you don\u0026rsquo;t set KUBECONFIG variable all configuration will be taken from $HOME/.kube/config\nObjects in kubectl config kubectl has in his config files following object types:\n clusters - info about K8s cluster - contain cluster name and connection parameters users - info about users by which you want connect to K8s clusters contexts - triple of cluster/user/namespace  Modifying config from kubectl Add cluster [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-cluster dev --server=https://192.168.1.100 --certificate-authority=fake-ca Cluster \u0026#34;dev\u0026#34; set. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-cluster prod --server=https://10.1.1.100 --certificate-authority=fake-ca Cluster \u0026#34;prod\u0026#34; set. Add users [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-credentials developer --client-certificate=fake-cert-file --client-key=fake-key-seefile User \u0026#34;developer\u0026#34; set. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-credentials prod_admin --client-certificate=fake-cert-file --client-key=fake-key-seefile User \u0026#34;prod_admin\u0026#34; set. Add contexts [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-context simple_app_development --cluster=dev --namespace=simple_app_dev --user=developer Context \u0026#34;simple_app_development\u0026#34; created. [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config set-context simple_app_production --cluster=prod --namespace=simple_app_prod --user=prod_admin Context \u0026#34;simple_app_production\u0026#34; created. Delete cluster/user/context from config kubectl --kubeconfig=.kube/additional_config config unset users.\u0026lt;name\u0026gt; kubectl --kubeconfig=.kube/additional_config config unset clusters.\u0026lt;name\u0026gt; kubectl --kubeconfig=.kube/additional_config config unset contexts.\u0026lt;name\u0026gt; Sample config [node1 ~]$ kubectl config --kubeconfig=.kube/additional_config view apiVersion: v1 clusters: - cluster: certificate-authority: /root/fake-ca server: https://192.168.1.100 name: dev - cluster: certificate-authority: /root/fake-ca server: https://10.1.1.100 name: prod contexts: - context: cluster: dev namespace: simple_app_dev user: developer name: simple_app_development - context: cluster: prod namespace: simple_app_prod user: prod_admin name: simple_app_production current-context: \u0026#34;\u0026#34; kind: Config preferences: {} users: - name: developer user: client-certificate: /root/fake-cert-file client-key: /root/fake-key-seefile - name: prod_admin user: client-certificate: /root/fake-cert-file client-key: /root/fake-key-seefile Changing context we working with To get list of contexts(no need for --kubeconfig because we have our additional_config added to KUBECONFIG variable):\n[node1 ~]$ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE simple_app_development dev developer simple_app_dev simple_app_production prod prod_admin simple_app_prod To set context:\n[node1 ~]$ kubectl config use-context simple_app_development Switched to context \u0026#34;simple_app_development\u0026#34;. To get current context:\n[node1 ~]$ kubectl config current-context simple_app_development ","href":"/posts/kubernetes_kubectl_client_config/","title":"Kubectl - configuration"},{"content":"","href":"/categories/kubernetes/","title":"kubernetes"},{"content":"","href":"/tags/docker-build/","title":"docker build"},{"content":"All docker containers are started from an image.\nWhat\u0026rsquo;s an image? Image is a collection of read only layers with everything we need to run application. Commonly in image we have base layout of operating system we had choose and some necessary binaries to start our application.\nFor exaple, for PostgreSQL container image could contain CentOS base filesystem template, PostgreSQL binaries and some configuration files.\nHow we build image? We build image by issuing command docker build, but before we use it we need to create a Docker file.\nSimplest-minimal command to build image:\ndocker build -t postgresql-server:11.6 .\nWe just use -t for setting image name and tag.\nDot at the end means that for build context we choose current dir - we could specify here full path to build context directory, which should provide Dockerfile and other files that we want to copy into our image at building process.\nAnother important docker build parameters are:\n --pull - Always pull a newer version of the image from which we build --no-cache - disable layer build cache --build-arg - send to docker daemon values for parameters from Dockerfile --file - choose custom Dockerfile location(out of build context directory)  For complete list check docker build -h\nBefore we use below command first we have to prepair Dockerfile.\nWhat is a Dockerfile? Dockerfile is text file with all commands needed to create environment for our application. We can easly define what files we want to include in our image, what binaries will run in container or what ports we want to expose from it. Using Dockerfile gives us possibility to fast create multiple enviroments just by modifying file and reissuing docker build.\nAssume that we have our java application in 0.1 version currently running - we get from dev team 0.2. Only thing we have to do is to change in Dockerfile path to jar file(or if we put app version in variable use parameter --build-arg - later about it in sample) and issue docker build - of course we should provide proper name for new image which will reflect app version. After image build we can start container with new application.\nSample Dockerfile FROMcentos:7LABEL maintainer=\u0026#34;lukas@mail.com\u0026#34;ARG PG_MAJORARG PG_MINORENV PG_MAJOR=${PG_MAJOR:-11}ENV PG_MINOR=${PG_MINOR:-5}ENV PG_PORT 5432ENV PG_USER_ID 2201ENV PG_USER_GID 2201ENV PG_ENCODING UTF8ENV PG_LOCALE en_US.UTF8ENV PG_AUTH md5ENV PG_AUTH_HOST md5ENV PG_AUTH_LOCAL md5RUN groupadd -g ${PG_USER_GID} postgres; useradd -g ${PG_USER_GID} -u ${PG_USER_ID} postgresCOPY my-yum-repo.repo /etc/yum.repos.d/RUN yum update -y; \\  yum -y install \\  postgresql11-server-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-contrib-${PG_MAJOR}.${PG_MINOR} \\  postgresql11-libs-${PG_MAJOR}.${PG_MINOR}; \\  yum clean all;ENV PATH $PATH:/usr/pgsql-${PG_MAJOR}/binENV PG_DIR /postgresqlENV PG_DATA ${PG_DIR}/data/pg${PG_MAJOR}ENV WAL_DATA ${PG_DIR}/walRUN set -ex; \\  mkdir -p ${PG_DIR}; \\  mkdir -p ${PG_DATA}; \\  mkdir -p ${WAL_DATA}; \\  mkdir -p ${PG_DIR}/archive; \\  mkdir -p ${PG_DIR}/backup; \\  mkdir -p ${PG_DIR}/log; \\  mkdir -p ${PG_DIR}/pgsql; \\  mkdir -p ${PG_DIR}/tmp; \\  chown -R postgres:postgres ${PG_DIR}; \\  chmod 750 -R ${PG_DIR};VOLUME${PG_DIR}VOLUME${WAL_DATA}COPY docker-entrypoint.sh /usr/local/binRUN chmod u+x /usr/local/bin/docker-entrypoint.shENTRYPOINT [\u0026#34;/usr/local/bin/docker-entrypoint.sh\u0026#34;]EXPOSE5432What commands in Dockerfile we have? FROM FROM [--platform=\u0026lt;platform\u0026gt;] \u0026lt;image\u0026gt;[:\u0026lt;tag\u0026gt;] [AS \u0026lt;name\u0026gt;]\nFROM centos7\nFROM tells Docker Engine which image it has to use as base image for current build.\n[--platform=\u0026lt;platform\u0026gt;] flag can be used to specify the platform of the image when we are building multi-platform image. For example, linux/amd64. By default image is build with platform on which build is triggered.\n[AS \u0026lt;name\u0026gt;] clause is used for creating multi stage builds. I will cover this topic in another post.\nIn example we use CentOS operating system, we didn\u0026rsquo;t specified any tag because we want newest CentOS image for version 7.\nEvery command under FROM directive will be run on base image. It\u0026rsquo;s important to notice that we don\u0026rsquo;t have to use as base images OS image. We can use any correctly build image, and build on top of it.\nIt is possible to parametrize image version specified in FROM clause with ARG and --build-arg.\nARG ARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;]\nARG PG_MAJOR\nARG PG_MINOR\nARG clause define build time variable.\nWe can pass parameters for it with --build-arg for docker build also we can specify default value for it in case of omitting in --build-arg by doing like ARG PG_MINOR=11.\nThis variables are available only at build time!\nIn our example we user ARG for PostgreSQL version. By doing so, we can build from one Dockerfile multiple images with different PostgreSQL engines. We can use ARG before FROM for parametrizing version of base image.\nENV ENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\nENV PG_PORT 5432\nENV clause define runtime variable.\nIn form without = sign - all characters after name of variable are treat as one string including whitespaces. The ENV variables will persist when a container is run. We can change them using docker run --env \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; on next container start.\nARG/ENV trick ARG PG_MAJOR\nARG PG_MINOR\nENV PG_MAJOR=${PG_MAJOR:-11}\nENV PG_MINOR=${PG_MINOR:-5}\nWhy we do something like this?\nAs mentioned, ENV - runtime variable, ARG build variable which can\u0026rsquo;t be accessed at container runtime.\nIn our example, we want to modify version of PostgreSQL which we will use at build time, but what if after build we need this variable values for some operations which can happen in some scripts in our container?\nTo persist this variables and make them available in running container we make ARG variables without default. Later we use them to set ENV's. Also we move default values set to ENV(shell syntax for setting default value).\nNow we can manipulate values with docker build --build-arg, but we also have them available after build at running container.\nLABEL LABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\nLABEL maintainer=\u0026quot;lukas@mail.com\u0026quot;\nLABEL is used for adding some metadata to image which we will be visible in docker inspect output.\nIn example we add info about image building person.\nWe can specify multiple labels - in multiple or one line.\nRUN RUN \u0026lt;command\u0026gt;\nRUN [\u0026quot;exec\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\nRUN chmod u+x /usr/local/bin/docker-entrypoint.sh\nRUN execute command on operating system of container.\nIf you just give command after RUN it will be execute in shell - for Linux it will be probably bash. If you use [](JSON form) it will execute command in raw mode - without shell characteristic behaviours. You should remember to use \u0026quot;\u0026rdquo; around each part of command.\nEach RUN command creates new layer in image. Lesser layers, the better. Always try to merge multiple commands making some logical unit of work into one RUN statement.\nFor example, appending to file, moving it and changing permissions.\nUse for it shell syntax like RUN \u0026lt;command\u0026gt;; \u0026lt;command2\u0026gt;; \u0026lt;command3\u0026gt; in Linux.\nCOPY \u0026amp; ADD ADD [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\nCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;src\u0026gt;... \u0026lt;dest\u0026gt;\nCOPY my-yum-repo.repo /etc/yum.repos.d/\nADD and COPY command will move files or directories from src to dest. In most cases COPY is command you need. ADD will be used only when you want to copy from URL - that is main difference between them, COPY don\u0026rsquo;t work over network - just local files.\nIn both cases build context is your \u0026ldquo;root\u0026rdquo; path from which you can use relative paths like somefolder/somefolder2/somefile\nIn both cases you can use wildcards like * or ?.\nIn both cases you can use [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] parameter to set owner and group for things that you place into image.\nVOLUME VOLUME [\u0026quot;\u0026lt;path\u0026gt;\u0026quot;]\nVOLUME ${PG_DIR}\nVOLUME creates mount point in filesystem of container for external volumes.\nENTRYPOINT \u0026amp; COMMAND ENTRYPOINT [\u0026quot;executable\u0026quot;, \u0026quot;param1\u0026quot;, \u0026quot;param2\u0026quot;]\nENTRYPOINT [\u0026quot;/usr/local/bin/docker-entrypoint.sh\u0026quot;]\nENTRYPOINT defines binary or shell script which will start immediately after starting container.\nIn our example we have docker-entrypoint.sh script which can contain logic like: if $PG_DATA empty initialize new postgresql cluster with initdb, if not empty - start postgresql with /usr/bin/postgres -D $PG_DATA.\nWe can pass arguments to ENTRYPOINT by adding it to docker run after image name.\nCOMMAND clause will be support command for ENTRYPOINT - it will hold default parameters for binary started in ENTRYPOINT in case when they are must exists and we do not pass anything to docker run. In our example there isn\u0026rsquo;t need for using COMMAND.\nIt is possible to override ENTRYPOINT when starting container with docker run --entrypoint parameter.\nEXPOSE EXPOSE \u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;/\u0026lt;protocol\u0026gt;]\nEXPOSE 5432\nEXPOSE is documentation command that shows at which ports services in container will listen.\nUSER USER \u0026lt;user\u0026gt;[:\u0026lt;group\u0026gt;]\nUSER instruction will set user from which all RUN, CMD and ENTRYPOINT commands will run.\nWORKDIR WORKDIR \u0026lt;path\u0026gt;\nWORKDIR will set current working directory for all RUN, CMD, ENTRYPOINT, COPY and ADD commands.\nONBUILD ONBUILD \u0026lt;dockerfile_command\u0026gt;\nONBUILD will trigger only if current image will be used as base image to build a new one. After ONBUILD we can specify any of the instructions explained below.\nExample Build process for our Dockerfile With file described below and other needed file in build context directory:\n[node1] (local) root@192.168.0.18 ~/postgres-build-dir $ ls -lah total 12K drwxr-xr-x 2 root root 76 Feb 28 16:14 . drwx------ 1 root root 48 Feb 28 16:14 .. -rw-r--r-- 1 root root 1.3K Feb 28 16:14 Dockerfile -rw-r--r-- 1 root root 99 Feb 28 16:15 docker-entrypoint.sh -rw-r--r-- 1 root root 40 Feb 28 16:15 my-yum-repo.repo Always have in context directory only necessary files for build process!\nAll this files will be transferred to docker daemon and could make your new image huge!\nWe can build postgresql image - notice that we are using --build-arg to overwrite default 11.5 version specified in dockerfile - let\u0026rsquo;s say that we need 11.6:\n[node1] (local) root@192.168.0.18 ~/postgres-build-dir $ docker build -t postgresql-server:11.6 --build-arg PG_MINOR=6 . Sending build context to Docker daemon 5.12kB Step 1/28 : FROM centos:7 7: Pulling from library/centos ab5ef0e58194: Extracting 75.78MB/75.78MB [..] ","href":"/posts/docker_build_from_dockerfile/","title":"Docker build from dockerfile - compendium"},{"content":"","href":"/tags/dockerfile/","title":"dockerfile"},{"content":"","href":"/tags/postgresql/","title":"postgresql"},{"content":"What are you looking for?\n","href":"/search/","title":""},{"content":"","href":"/series/","title":"Series"}]
